{"ast":null,"code":"var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nvar __objRest = (source, exclude) => {\n  var target = {};\n\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\n\nvar __export = (target, all) => {\n  for (var name in all) __defProp(target, name, {\n    get: all[name],\n    enumerable: true\n  });\n};\n\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from)) if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n      get: () => from[key],\n      enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n    });\n  }\n\n  return to;\n};\n\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n  value: mod,\n  enumerable: true\n}) : target, mod));\n\nvar __toCommonJS = mod => __copyProps(__defProp({}, \"__esModule\", {\n  value: true\n}), mod); // src/index.ts\n\n\nvar src_exports = {};\n\n__export(src_exports, {\n  GraphQLHandler: () => GraphQLHandler,\n  MockedRequest: () => MockedRequest,\n  RESTMethods: () => RESTMethods,\n  RequestHandler: () => RequestHandler,\n  RestHandler: () => RestHandler,\n  cleanUrl: () => cleanUrl,\n  compose: () => compose,\n  context: () => context_exports,\n  createResponseComposition: () => createResponseComposition,\n  defaultContext: () => defaultContext,\n  defaultResponse: () => defaultResponse,\n  graphql: () => graphql,\n  graphqlContext: () => graphqlContext,\n  handleRequest: () => handleRequest,\n  matchRequestUrl: () => matchRequestUrl,\n  response: () => response,\n  rest: () => rest,\n  restContext: () => restContext,\n  setupWorker: () => setupWorker\n});\n\nmodule.exports = __toCommonJS(src_exports); // src/context/index.ts\n\nvar context_exports = {};\n\n__export(context_exports, {\n  body: () => body,\n  cookie: () => cookie,\n  data: () => data,\n  delay: () => delay,\n  errors: () => errors,\n  extensions: () => extensions,\n  fetch: () => fetch,\n  json: () => json,\n  set: () => set,\n  status: () => status,\n  text: () => text,\n  xml: () => xml\n}); // src/context/status.ts\n\n\nvar import_codes = __toESM(require(\"statuses/codes.json\"));\n\nvar status = (statusCode, statusText) => {\n  return res => {\n    res.status = statusCode;\n    res.statusText = statusText || import_codes.default[String(statusCode)];\n    return res;\n  };\n}; // src/context/set.ts\n\n\nvar import_headers_polyfill = require(\"headers-polyfill\");\n\nfunction set() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return res => {\n    const [name, value] = args;\n\n    if (typeof name === \"string\") {\n      res.headers.append(name, value);\n    } else {\n      const headers = (0, import_headers_polyfill.objectToHeaders)(name);\n      headers.forEach((value2, name2) => {\n        res.headers.append(name2, value2);\n      });\n    }\n\n    return res;\n  };\n} // src/context/cookie.ts\n\n\nvar cookieUtils = __toESM(require(\"cookie\"));\n\nvar cookie = (name, value, options) => {\n  return res => {\n    const serializedCookie = cookieUtils.serialize(name, value, options);\n    res.headers.append(\"Set-Cookie\", serializedCookie);\n\n    if (typeof document !== \"undefined\") {\n      document.cookie = serializedCookie;\n    }\n\n    return res;\n  };\n}; // src/context/body.ts\n\n\nvar body = value => {\n  return res => {\n    res.body = value;\n    return res;\n  };\n}; // src/utils/internal/jsonParse.ts\n\n\nfunction jsonParse(value) {\n  try {\n    return JSON.parse(value);\n  } catch (error2) {\n    return void 0;\n  }\n} // src/utils/internal/isObject.ts\n\n\nfunction isObject(value) {\n  return value != null && typeof value === \"object\" && !Array.isArray(value);\n} // src/utils/internal/mergeRight.ts\n\n\nfunction mergeRight(left, right) {\n  return Object.entries(right).reduce((result, _ref) => {\n    let [key, rightValue] = _ref;\n    const leftValue = result[key];\n\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue);\n      return result;\n    }\n\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue);\n      return result;\n    }\n\n    result[key] = rightValue;\n    return result;\n  }, Object.assign({}, left));\n} // src/context/json.ts\n\n\nvar json = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"application/json\");\n    res.body = JSON.stringify(body2);\n    return res;\n  };\n}; // src/context/data.ts\n\n\nvar data = payload => {\n  return res => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      data: payload\n    });\n    return json(nextBody)(res);\n  };\n}; // src/context/extensions.ts\n\n\nvar extensions = payload => {\n  return res => {\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      extensions: payload\n    });\n    return json(nextBody)(res);\n  };\n}; // src/context/delay.ts\n\n\nvar import_is_node_process = require(\"is-node-process\");\n\nvar SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647;\nvar MIN_SERVER_RESPONSE_TIME = 100;\nvar MAX_SERVER_RESPONSE_TIME = 400;\nvar NODE_SERVER_RESPONSE_TIME = 5;\n\nvar getRandomServerResponseTime = () => {\n  if ((0, import_is_node_process.isNodeProcess)()) {\n    return NODE_SERVER_RESPONSE_TIME;\n  }\n\n  return Math.floor(Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) + MIN_SERVER_RESPONSE_TIME);\n};\n\nvar delay = durationOrMode => {\n  return res => {\n    let delayTime;\n\n    if (typeof durationOrMode === \"string\") {\n      switch (durationOrMode) {\n        case \"infinite\":\n          {\n            delayTime = SET_TIMEOUT_MAX_ALLOWED_INT;\n            break;\n          }\n\n        case \"real\":\n          {\n            delayTime = getRandomServerResponseTime();\n            break;\n          }\n\n        default:\n          {\n            throw new Error(`Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`);\n          }\n      }\n    } else if (typeof durationOrMode === \"undefined\") {\n      delayTime = getRandomServerResponseTime();\n    } else {\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(`Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`);\n      }\n\n      delayTime = durationOrMode;\n    }\n\n    res.delay = delayTime;\n    return res;\n  };\n}; // src/context/errors.ts\n\n\nvar errors = errorsList => {\n  return res => {\n    if (errorsList == null) {\n      return res;\n    }\n\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      errors: errorsList\n    });\n    return json(nextBody)(res);\n  };\n}; // src/context/fetch.ts\n\n\nvar import_is_node_process2 = require(\"is-node-process\");\n\nvar import_headers_polyfill2 = require(\"headers-polyfill\");\n\nvar useFetch = (0, import_is_node_process2.isNodeProcess)() ? require(\"node-fetch\") : window.fetch;\n\nvar augmentRequestInit = requestInit => {\n  const headers = new import_headers_polyfill2.Headers(requestInit.headers);\n  headers.set(\"x-msw-bypass\", \"true\");\n  return __spreadProps(__spreadValues({}, requestInit), {\n    headers: headers.all()\n  });\n};\n\nvar createFetchRequestParameters = input => {\n  const {\n    body: body2,\n    method\n  } = input;\n\n  const requestParameters = __spreadProps(__spreadValues({}, input), {\n    body: void 0\n  });\n\n  if ([\"GET\", \"HEAD\"].includes(method)) {\n    return requestParameters;\n  }\n\n  if (typeof body2 === \"object\" || typeof body2 === \"number\" || typeof body2 === \"boolean\") {\n    requestParameters.body = JSON.stringify(body2);\n  } else {\n    requestParameters.body = body2;\n  }\n\n  return requestParameters;\n};\n\nvar fetch = function (input) {\n  let requestInit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof input === \"string\") {\n    return useFetch(input, augmentRequestInit(requestInit));\n  }\n\n  const requestParameters = createFetchRequestParameters(input);\n  const derivedRequestInit = augmentRequestInit(requestParameters);\n  return useFetch(input.url.href, derivedRequestInit);\n}; // src/context/text.ts\n\n\nvar text = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"text/plain\");\n    res.body = body2;\n    return res;\n  };\n}; // src/context/xml.ts\n\n\nvar xml = body2 => {\n  return res => {\n    res.headers.set(\"Content-Type\", \"text/xml\");\n    res.body = body2;\n    return res;\n  };\n}; // src/setupWorker/setupWorker.ts\n\n\nvar import_is_node_process3 = require(\"is-node-process\");\n\nvar import_strict_event_emitter = require(\"strict-event-emitter\"); // src/setupWorker/start/createStartHandler.ts\n\n\nvar import_until4 = require(\"@open-draft/until\"); // src/setupWorker/start/utils/getWorkerInstance.ts\n\n\nvar import_until = require(\"@open-draft/until\"); // src/setupWorker/start/utils/getWorkerByRegistration.ts\n\n\nvar getWorkerByRegistration = (registration, absoluteWorkerUrl, findWorker) => {\n  const allStates = [registration.active, registration.installing, registration.waiting];\n  const existingStates = allStates.filter(Boolean);\n  const mockWorker = existingStates.find(worker => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl);\n  });\n  return mockWorker || null;\n}; // src/utils/url/getAbsoluteWorkerUrl.ts\n\n\nfunction getAbsoluteWorkerUrl(relativeUrl) {\n  return new URL(relativeUrl, location.origin).href;\n} // src/utils/internal/devUtils.ts\n\n\nvar import_outvariant = require(\"outvariant\");\n\nvar LIBRARY_PREFIX = \"[MSW]\";\n\nfunction formatMessage(message) {\n  for (var _len2 = arguments.length, positionals = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    positionals[_key2 - 1] = arguments[_key2];\n  }\n\n  const interpolatedMessage = (0, import_outvariant.format)(message, ...positionals);\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`;\n}\n\nfunction warn(message) {\n  for (var _len3 = arguments.length, positionals = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    positionals[_key3 - 1] = arguments[_key3];\n  }\n\n  console.warn(formatMessage(message, ...positionals));\n}\n\nfunction error(message) {\n  for (var _len4 = arguments.length, positionals = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    positionals[_key4 - 1] = arguments[_key4];\n  }\n\n  console.error(formatMessage(message, ...positionals));\n}\n\nvar devUtils = {\n  formatMessage,\n  warn,\n  error\n}; // src/setupWorker/start/utils/getWorkerInstance.ts\n\nvar getWorkerInstance = async function (url) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let findWorker = arguments.length > 2 ? arguments[2] : undefined;\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url);\n  const mockRegistrations = await navigator.serviceWorker.getRegistrations().then(registrations => registrations.filter(registration => getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker)));\n\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    location.reload();\n  }\n\n  const [existingRegistration] = mockRegistrations;\n\n  if (existingRegistration) {\n    return existingRegistration.update().then(() => {\n      return [getWorkerByRegistration(existingRegistration, absoluteWorkerUrl, findWorker), existingRegistration];\n    });\n  }\n\n  const [error2, instance] = await (0, import_until.until)(async () => {\n    const registration = await navigator.serviceWorker.register(url, options);\n    return [getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker), registration];\n  });\n\n  if (error2) {\n    const isWorkerMissing = error2.message.includes(\"(404)\");\n\n    if (isWorkerMissing) {\n      const scopeUrl = new URL((options == null ? void 0 : options.scope) || \"/\", location.href);\n      throw new Error(devUtils.formatMessage(`Failed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`));\n    }\n\n    throw new Error(devUtils.formatMessage(\"Failed to register the Service Worker:\\n\\n%s\", error2.message));\n  }\n\n  return instance;\n}; // src/setupWorker/start/utils/printStartMessage.ts\n\n\nfunction printStartMessage() {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (args.quiet) {\n    return;\n  }\n\n  const message = args.message || \"Mocking enabled.\";\n  console.groupCollapsed(`%c${devUtils.formatMessage(message)}`, \"color:orangered;font-weight:bold;\");\n  console.log(\"%cDocumentation: %chttps://mswjs.io/docs\", \"font-weight:bold\", \"font-weight:normal\");\n  console.log(\"Found an issue? https://github.com/mswjs/msw/issues\");\n\n  if (args.workerUrl) {\n    console.log(\"Worker script URL:\", args.workerUrl);\n  }\n\n  if (args.workerScope) {\n    console.log(\"Worker scope:\", args.workerScope);\n  }\n\n  console.groupEnd();\n} // src/setupWorker/start/utils/enableMocking.ts\n\n\nasync function enableMocking(context, options) {\n  var _a, _b;\n\n  context.workerChannel.send(\"MOCK_ACTIVATE\");\n  await context.events.once(\"MOCKING_ENABLED\");\n\n  if (context.isMockingEnabled) {\n    devUtils.warn(`Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`);\n    return;\n  }\n\n  context.isMockingEnabled = true;\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: (_a = context.registration) == null ? void 0 : _a.scope,\n    workerUrl: (_b = context.worker) == null ? void 0 : _b.scriptURL\n  });\n} // src/setupWorker/start/utils/createMessageChannel.ts\n\n\nvar WorkerChannel = class {\n  constructor(port) {\n    this.port = port;\n  }\n\n  postMessage(event) {\n    for (var _len5 = arguments.length, rest2 = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      rest2[_key5 - 1] = arguments[_key5];\n    }\n\n    const [data2, transfer] = rest2;\n    this.port.postMessage({\n      type: event,\n      data: data2\n    }, {\n      transfer\n    });\n  }\n\n}; // src/utils/NetworkError.ts\n\nvar NetworkError = class extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"NetworkError\";\n  }\n\n}; // src/utils/request/parseWorkerRequest.ts\n\nvar import_interceptors2 = require(\"@mswjs/interceptors\");\n\nvar import_headers_polyfill5 = require(\"headers-polyfill\"); // src/utils/request/MockedRequest.ts\n\n\nvar cookieUtils3 = __toESM(require(\"cookie\"));\n\nvar import_cookies = require(\"@mswjs/cookies\");\n\nvar import_interceptors = require(\"@mswjs/interceptors\");\n\nvar import_bufferUtils = require(\"@mswjs/interceptors/lib/utils/bufferUtils\");\n\nvar import_headers_polyfill4 = require(\"headers-polyfill\"); // src/utils/request/getRequestCookies.ts\n\n\nvar cookieUtils2 = __toESM(require(\"cookie\"));\n\nfunction getAllCookies() {\n  return cookieUtils2.parse(document.cookie);\n}\n\nfunction getRequestCookies(request) {\n  if (typeof document === \"undefined\" || typeof location === \"undefined\") {\n    return {};\n  }\n\n  switch (request.credentials) {\n    case \"same-origin\":\n      {\n        return location.origin === request.url.origin ? getAllCookies() : {};\n      }\n\n    case \"include\":\n      {\n        return getAllCookies();\n      }\n\n    default:\n      {\n        return {};\n      }\n  }\n} // src/utils/internal/parseMultipartData.ts\n\n\nvar import_headers_polyfill3 = require(\"headers-polyfill\");\n\nfunction parseContentHeaders(headersString) {\n  var _a, _b;\n\n  const headers = (0, import_headers_polyfill3.stringToHeaders)(headersString);\n  const contentType = headers.get(\"content-type\") || \"text/plain\";\n  const disposition = headers.get(\"content-disposition\");\n\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.');\n  }\n\n  const directives = disposition.split(\";\").reduce((acc, chunk) => {\n    const [name2, ...rest2] = chunk.trim().split(\"=\");\n    acc[name2] = rest2.join(\"=\");\n    return acc;\n  }, {});\n  const name = (_a = directives.name) == null ? void 0 : _a.slice(1, -1);\n  const filename = (_b = directives.filename) == null ? void 0 : _b.slice(1, -1);\n  return {\n    name,\n    filename,\n    contentType\n  };\n}\n\nfunction parseMultipartData(data2, headers) {\n  const contentType = headers == null ? void 0 : headers.get(\"content-type\");\n\n  if (!contentType) {\n    return void 0;\n  }\n\n  const [, ...directives] = contentType.split(/; */);\n  const boundary = directives.filter(d => d.startsWith(\"boundary=\")).map(s => s.replace(/^boundary=/, \"\"))[0];\n\n  if (!boundary) {\n    return void 0;\n  }\n\n  const boundaryRegExp = new RegExp(`--+${boundary}`);\n  const fields = data2.split(boundaryRegExp).filter(chunk => chunk.startsWith(\"\\r\\n\") && chunk.endsWith(\"\\r\\n\")).map(chunk => chunk.trimStart().replace(/\\r\\n$/, \"\"));\n\n  if (!fields.length) {\n    return void 0;\n  }\n\n  const parsedBody = {};\n\n  try {\n    for (const field2 of fields) {\n      const [contentHeaders, ...rest2] = field2.split(\"\\r\\n\\r\\n\");\n      const contentBody = rest2.join(\"\\r\\n\\r\\n\");\n      const {\n        contentType: contentType2,\n        filename,\n        name\n      } = parseContentHeaders(contentHeaders);\n      const value = filename === void 0 ? contentBody : new File([contentBody], filename, {\n        type: contentType2\n      });\n      const parsedValue = parsedBody[name];\n\n      if (parsedValue === void 0) {\n        parsedBody[name] = value;\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value];\n      } else {\n        parsedBody[name] = [parsedValue, value];\n      }\n    }\n\n    return parsedBody;\n  } catch (error2) {\n    return void 0;\n  }\n} // src/utils/request/parseBody.ts\n\n\nfunction parseBody(body2, headers) {\n  var _a;\n\n  if (!body2) {\n    return body2;\n  }\n\n  const contentType = ((_a = headers == null ? void 0 : headers.get(\"content-type\")) == null ? void 0 : _a.toLowerCase()) || \"\";\n  const hasMultipartContent = contentType.startsWith(\"multipart/form-data\");\n\n  if (hasMultipartContent && typeof body2 !== \"object\") {\n    return parseMultipartData(body2.toString(), headers) || body2;\n  }\n\n  const hasJsonContent = contentType.includes(\"json\");\n\n  if (hasJsonContent && typeof body2 !== \"object\") {\n    return jsonParse(body2.toString()) || body2;\n  }\n\n  return body2;\n} // src/utils/internal/isStringEqual.ts\n\n\nfunction isStringEqual(actual, expected) {\n  return actual.toLowerCase() === expected.toLowerCase();\n} // src/utils/request/MockedRequest.ts\n\n\nvar MockedRequest = class extends import_interceptors.IsomorphicRequest {\n  constructor(url) {\n    let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(url, init);\n\n    if (init.id) {\n      this.id = init.id;\n    }\n\n    this.cache = init.cache || \"default\";\n    this.destination = init.destination || \"\";\n    this.integrity = init.integrity || \"\";\n    this.keepalive = init.keepalive || false;\n    this.mode = init.mode || \"cors\";\n    this.priority = init.priority || \"auto\";\n    this.redirect = init.redirect || \"follow\";\n    this.referrer = init.referrer || \"\";\n    this.referrerPolicy = init.referrerPolicy || \"no-referrer\";\n    this.cookies = init.cookies || this.getCookies();\n  }\n\n  get body() {\n    const text2 = (0, import_bufferUtils.decodeBuffer)(this[\"_body\"]);\n    const body2 = parseBody(text2, this.headers);\n\n    if (isStringEqual(this.method, \"GET\") && body2 === \"\") {\n      return void 0;\n    }\n\n    return body2;\n  }\n\n  passthrough() {\n    return {\n      status: 101,\n      statusText: \"Continue\",\n      headers: new import_headers_polyfill4.Headers(),\n      body: null,\n      passthrough: true,\n      once: false\n    };\n  }\n\n  getCookies() {\n    var _a;\n\n    const requestCookiesString = this.headers.get(\"cookie\");\n    const ownCookies = requestCookiesString ? cookieUtils3.parse(requestCookiesString) : {};\n    import_cookies.store.hydrate();\n    const cookiesFromStore = Array.from((_a = import_cookies.store.get(__spreadProps(__spreadValues({}, this), {\n      url: this.url.href\n    }))) == null ? void 0 : _a.entries()).reduce((cookies, _ref2) => {\n      let [name, {\n        value\n      }] = _ref2;\n      return Object.assign(cookies, {\n        [name.trim()]: value\n      });\n    }, {});\n    const cookiesFromDocument = getRequestCookies(this);\n\n    const forwardedCookies = __spreadValues(__spreadValues({}, cookiesFromDocument), cookiesFromStore);\n\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append(\"cookie\", `${name}=${value}`);\n    }\n\n    return __spreadValues(__spreadValues({}, forwardedCookies), ownCookies);\n  }\n\n}; // src/utils/request/parseWorkerRequest.ts\n\nfunction parseWorkerRequest(rawRequest) {\n  const url = new URL(rawRequest.url);\n  const headers = new import_headers_polyfill5.Headers(rawRequest.headers);\n  return new MockedRequest(url, __spreadProps(__spreadValues({}, rawRequest), {\n    body: (0, import_interceptors2.encodeBuffer)(rawRequest.body || \"\"),\n    headers\n  }));\n} // src/utils/handleRequest.ts\n\n\nvar import_until2 = require(\"@open-draft/until\"); // src/utils/getResponse.ts\n\n\nvar getResponse = async (request, handlers, resolutionContext) => {\n  const relevantHandlers = handlers.filter(handler => {\n    return handler.test(request, resolutionContext);\n  });\n\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n\n  const result = await relevantHandlers.reduce(async (executionResult, handler) => {\n    const previousResults = await executionResult;\n\n    if (!!(previousResults == null ? void 0 : previousResults.response)) {\n      return executionResult;\n    }\n\n    const result2 = await handler.run(request, resolutionContext);\n\n    if (result2 === null || result2.handler.shouldSkip) {\n      return null;\n    }\n\n    if (!result2.response) {\n      return {\n        request: result2.request,\n        handler: result2.handler,\n        response: void 0,\n        parsedResult: result2.parsedResult\n      };\n    }\n\n    if (result2.response.once) {\n      handler.markAsSkipped(true);\n    }\n\n    return result2;\n  }, Promise.resolve(null));\n\n  if (!result) {\n    return {\n      handler: void 0,\n      response: void 0\n    };\n  }\n\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response\n  };\n}; // src/utils/request/onUnhandledRequest.ts\n\n\nvar import_js_levenshtein = __toESM(require(\"js-levenshtein\")); // src/utils/internal/parseGraphQLRequest.ts\n\n\nvar import_graphql = require(\"graphql\"); // src/utils/request/getPublicUrlFromRequest.ts\n\n\nvar getPublicUrlFromRequest = request => {\n  return request.referrer.startsWith(request.url.origin) ? request.url.pathname : new URL(request.url.pathname, `${request.url.protocol}//${request.url.host}`).href;\n}; // src/utils/internal/parseGraphQLRequest.ts\n\n\nfunction parseDocumentNode(node) {\n  var _a;\n\n  const operationDef = node.definitions.find(def => {\n    return def.kind === \"OperationDefinition\";\n  });\n  return {\n    operationType: operationDef == null ? void 0 : operationDef.operation,\n    operationName: (_a = operationDef == null ? void 0 : operationDef.name) == null ? void 0 : _a.value\n  };\n}\n\nfunction parseQuery(query) {\n  try {\n    const ast = (0, import_graphql.parse)(query);\n    return parseDocumentNode(ast);\n  } catch (error2) {\n    return error2;\n  }\n}\n\nfunction extractMultipartVariables(variables, map, files) {\n  const operations = {\n    variables\n  };\n\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`);\n    }\n\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split(\".\").reverse();\n      const paths = reversedPaths.reverse();\n      let target = operations;\n\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`);\n        }\n\n        target = target[path];\n      }\n\n      target[lastPath] = files[key];\n    }\n  }\n\n  return operations.variables;\n}\n\nfunction getGraphQLInput(request) {\n  var _a, _b;\n\n  switch (request.method) {\n    case \"GET\":\n      {\n        const query = request.url.searchParams.get(\"query\");\n        const variables = request.url.searchParams.get(\"variables\") || \"\";\n        return {\n          query,\n          variables: jsonParse(variables)\n        };\n      }\n\n    case \"POST\":\n      {\n        if ((_a = request.body) == null ? void 0 : _a.query) {\n          const {\n            query,\n            variables\n          } = request.body;\n          return {\n            query,\n            variables\n          };\n        }\n\n        if ((_b = request.body) == null ? void 0 : _b.operations) {\n          const _c = request.body,\n                {\n            operations,\n            map\n          } = _c,\n                files = __objRest(_c, [\"operations\", \"map\"]);\n\n          const parsedOperations = jsonParse(operations) || {};\n\n          if (!parsedOperations.query) {\n            return null;\n          }\n\n          const parsedMap = jsonParse(map || \"\") || {};\n          const variables = parsedOperations.variables ? extractMultipartVariables(parsedOperations.variables, parsedMap, files) : {};\n          return {\n            query: parsedOperations.query,\n            variables\n          };\n        }\n      }\n\n    default:\n      return null;\n  }\n}\n\nfunction parseGraphQLRequest(request) {\n  const input = getGraphQLInput(request);\n\n  if (!input || !input.query) {\n    return void 0;\n  }\n\n  const {\n    query,\n    variables\n  } = input;\n  const parsedResult = parseQuery(query);\n\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    throw new Error(devUtils.formatMessage('Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s', request.method, requestPublicUrl, parsedResult.message));\n  }\n\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables\n  };\n} // src/utils/logging/getStatusCodeColor.ts\n\n\nfunction getStatusCodeColor(status2) {\n  if (status2 < 300) {\n    return \"#69AB32\"\n    /* Success */\n    ;\n  }\n\n  if (status2 < 400) {\n    return \"#F0BB4B\"\n    /* Warning */\n    ;\n  }\n\n  return \"#E95F5D\"\n  /* Danger */\n  ;\n} // src/utils/logging/getTimestamp.ts\n\n\nfunction getTimestamp() {\n  const now = new Date();\n  return [now.getHours(), now.getMinutes(), now.getSeconds()].map(String).map(chunk => chunk.slice(0, 2)).map(chunk => chunk.padStart(2, \"0\")).join(\":\");\n} // src/utils/logging/prepareRequest.ts\n\n\nfunction prepareRequest(request) {\n  return __spreadProps(__spreadValues({}, request), {\n    body: request.body,\n    headers: request.headers.all()\n  });\n} // src/utils/logging/prepareResponse.ts\n\n\nvar import_headers_polyfill6 = require(\"headers-polyfill\");\n\nfunction prepareResponse(res) {\n  const responseHeaders = (0, import_headers_polyfill6.objectToHeaders)(res.headers);\n  return __spreadProps(__spreadValues({}, res), {\n    body: parseBody(res.body, responseHeaders)\n  });\n} // src/utils/matching/matchRequestUrl.ts\n\n\nvar import_path_to_regexp = require(\"path-to-regexp\");\n\nvar import_getCleanUrl = require(\"@mswjs/interceptors/lib/utils/getCleanUrl\"); // src/utils/url/cleanUrl.ts\n\n\nvar REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g;\n\nfunction getSearchParams(path) {\n  return new URL(`/${path}`, \"http://localhost\").searchParams;\n}\n\nfunction cleanUrl(path) {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, \"\");\n} // src/utils/url/isAbsoluteUrl.ts\n\n\nfunction isAbsoluteUrl(url) {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url);\n} // src/utils/url/getAbsoluteUrl.ts\n\n\nfunction getAbsoluteUrl(path, baseUrl) {\n  if (isAbsoluteUrl(path)) {\n    return path;\n  }\n\n  if (path.startsWith(\"*\")) {\n    return path;\n  }\n\n  const origin = baseUrl || typeof document !== \"undefined\" && document.baseURI;\n  return origin ? decodeURI(new URL(encodeURI(path), origin).href) : path;\n} // src/utils/matching/normalizePath.ts\n\n\nfunction normalizePath(path, baseUrl) {\n  if (path instanceof RegExp) {\n    return path;\n  }\n\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl);\n  return cleanUrl(maybeAbsoluteUrl);\n} // src/utils/matching/matchRequestUrl.ts\n\n\nfunction coercePath(path) {\n  return path.replace(/([:a-zA-Z_-]*)(\\*{1,2})+/g, (_, parameterName, wildcard) => {\n    const expression = \"(.*)\";\n\n    if (!parameterName) {\n      return expression;\n    }\n\n    return parameterName.startsWith(\":\") ? `${parameterName}${wildcard}` : `${parameterName}${expression}`;\n  }).replace(/([^\\/])(:)(?=\\d+)/, \"$1\\\\$2\").replace(/^([^\\/]+)(:)(?=\\/\\/)/, \"$1\\\\$2\");\n}\n\nfunction matchRequestUrl(url, path, baseUrl) {\n  const normalizedPath = normalizePath(path, baseUrl);\n  const cleanPath = typeof normalizedPath === \"string\" ? coercePath(normalizedPath) : normalizedPath;\n  const cleanUrl2 = (0, import_getCleanUrl.getCleanUrl)(url);\n  const result = (0, import_path_to_regexp.match)(cleanPath, {\n    decode: decodeURIComponent\n  })(cleanUrl2);\n  const params = result && result.params || {};\n  return {\n    matches: result !== false,\n    params\n  };\n} // src/handlers/RequestHandler.ts\n\n\nvar import_headers_polyfill8 = require(\"headers-polyfill\"); // src/response.ts\n\n\nvar import_headers_polyfill7 = require(\"headers-polyfill\"); // src/utils/internal/compose.ts\n\n\nfunction compose() {\n  for (var _len6 = arguments.length, fns = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    fns[_key6] = arguments[_key6];\n  }\n\n  return function () {\n    return fns.reduceRight((leftFn, rightFn) => {\n      return leftFn instanceof Promise ? Promise.resolve(leftFn).then(rightFn) : rightFn(leftFn);\n    }, arguments.length <= 0 ? undefined : arguments[0]);\n  };\n} // src/response.ts\n\n\nvar defaultResponse = {\n  status: 200,\n  statusText: \"OK\",\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false\n};\nvar defaultResponseTransformers = [];\n\nfunction createResponseComposition(responseOverrides) {\n  let defaultTransformers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultResponseTransformers;\n  return async function () {\n    const initialResponse = Object.assign({}, defaultResponse, {\n      headers: new import_headers_polyfill7.Headers({\n        \"x-powered-by\": \"msw\"\n      })\n    }, responseOverrides);\n\n    for (var _len7 = arguments.length, transformers = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      transformers[_key7] = arguments[_key7];\n    }\n\n    const resolvedTransformers = [...defaultTransformers, ...transformers].filter(Boolean);\n    const resolvedResponse = resolvedTransformers.length > 0 ? compose(...resolvedTransformers)(initialResponse) : initialResponse;\n    return resolvedResponse;\n  };\n}\n\nvar response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({\n    once: true\n  }),\n\n  networkError(message) {\n    throw new NetworkError(message);\n  }\n\n}); // src/utils/internal/getCallFrame.ts\n\nvar SOURCE_FRAME = /\\/msw\\/src\\/(.+)/;\nvar BUILD_FRAME = /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/;\n\nfunction getCallFrame(error2) {\n  const stack = error2.stack;\n\n  if (!stack) {\n    return;\n  }\n\n  const frames = stack.split(\"\\n\").slice(1);\n  const declarationFrame = frames.find(frame => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame));\n  });\n\n  if (!declarationFrame) {\n    return;\n  }\n\n  const declarationPath = declarationFrame.replace(/\\s*at [^()]*\\(([^)]+)\\)/, \"$1\").replace(/^@/, \"\");\n  return declarationPath;\n} // src/utils/internal/isIterable.ts\n\n\nfunction isIterable(fn) {\n  if (!fn) {\n    return false;\n  }\n\n  return typeof fn[Symbol.iterator] == \"function\";\n} // src/handlers/RequestHandler.ts\n\n\nvar defaultContext = {\n  status,\n  set,\n  delay,\n  fetch\n};\nvar RequestHandler = class {\n  constructor(options) {\n    this.shouldSkip = false;\n    this.ctx = options.ctx || defaultContext;\n    this.resolver = options.resolver;\n    const callFrame = getCallFrame(new Error());\n    this.info = __spreadProps(__spreadValues({}, options.info), {\n      callFrame\n    });\n  }\n\n  parse(_request, _resolutionContext) {\n    return null;\n  }\n\n  test(request, resolutionContext) {\n    return this.predicate(request, this.parse(request, resolutionContext), resolutionContext);\n  }\n\n  getPublicRequest(request, _parsedResult) {\n    return request;\n  }\n\n  markAsSkipped() {\n    let shouldSkip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    this.shouldSkip = shouldSkip;\n  }\n\n  async run(request, resolutionContext) {\n    if (this.shouldSkip) {\n      return null;\n    }\n\n    const parsedResult = this.parse(request, resolutionContext);\n    const shouldIntercept = this.predicate(request, parsedResult, resolutionContext);\n\n    if (!shouldIntercept) {\n      return null;\n    }\n\n    const publicRequest = this.getPublicRequest(request, parsedResult);\n    const executeResolver = this.wrapResolver(this.resolver);\n    const mockedResponse = await executeResolver(publicRequest, response, this.ctx);\n    return this.createExecutionResult(parsedResult, publicRequest, mockedResponse);\n  }\n\n  wrapResolver(resolver) {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || (await resolver(req, res, ctx));\n\n      if (isIterable(result)) {\n        const {\n          value,\n          done\n        } = result[Symbol.iterator]().next();\n        const nextResponse = await value;\n\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult;\n        }\n\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result;\n        }\n\n        this.resolverGeneratorResult = nextResponse;\n        return nextResponse;\n      }\n\n      return result;\n    };\n  }\n\n  createExecutionResult(parsedResult, request, response2) {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response2 || null\n    };\n  }\n\n}; // src/handlers/RestHandler.ts\n\nvar RESTMethods = /* @__PURE__ */(RESTMethods2 => {\n  RESTMethods2[\"HEAD\"] = \"HEAD\";\n  RESTMethods2[\"GET\"] = \"GET\";\n  RESTMethods2[\"POST\"] = \"POST\";\n  RESTMethods2[\"PUT\"] = \"PUT\";\n  RESTMethods2[\"PATCH\"] = \"PATCH\";\n  RESTMethods2[\"OPTIONS\"] = \"OPTIONS\";\n  RESTMethods2[\"DELETE\"] = \"DELETE\";\n  return RESTMethods2;\n})(RESTMethods || {});\n\nvar restContext = __spreadProps(__spreadValues({}, defaultContext), {\n  cookie,\n  body,\n  text,\n  json,\n  xml\n});\n\nvar RestRequest = class extends MockedRequest {\n  constructor(request, params) {\n    super(request.url, __spreadProps(__spreadValues({}, request), {\n      body: request[\"_body\"]\n    }));\n    this.params = params;\n    this.id = request.id;\n  }\n\n};\nvar RestHandler = class extends RequestHandler {\n  constructor(method, path, resolver) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method\n      },\n      ctx: restContext,\n      resolver\n    });\n    this.checkRedundantQueryParameters();\n  }\n\n  checkRedundantQueryParameters() {\n    const {\n      method,\n      path\n    } = this.info;\n\n    if (path instanceof RegExp) {\n      return;\n    }\n\n    const url = cleanUrl(path);\n\n    if (url === path) {\n      return;\n    }\n\n    const searchParams = getSearchParams(path);\n    const queryParams = [];\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName);\n    });\n    devUtils.warn(`Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`);\n  }\n\n  parse(request, resolutionContext) {\n    return matchRequestUrl(request.url, this.info.path, resolutionContext == null ? void 0 : resolutionContext.baseUrl);\n  }\n\n  getPublicRequest(request, parsedResult) {\n    return new RestRequest(request, parsedResult.params || {});\n  }\n\n  predicate(request, parsedResult) {\n    const matchesMethod = this.info.method instanceof RegExp ? this.info.method.test(request.method) : isStringEqual(this.info.method, request.method);\n    return matchesMethod && parsedResult.matches;\n  }\n\n  log(request, response2) {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    console.groupCollapsed(devUtils.formatMessage(\"%s %s %s (%c%s%c)\"), getTimestamp(), request.method, publicUrl, `color:${statusColor}`, `${response2.status} ${response2.statusText}`, \"color:inherit\");\n    console.log(\"Request\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response\", loggedResponse);\n    console.groupEnd();\n  }\n\n}; // src/context/field.ts\n\nvar import_outvariant2 = require(\"outvariant\");\n\nvar field = (fieldName, fieldValue) => {\n  return res => {\n    validateFieldName(fieldName);\n    const prevBody = jsonParse(res.body) || {};\n    const nextBody = mergeRight(prevBody, {\n      [fieldName]: fieldValue\n    });\n    return json(nextBody)(res);\n  };\n};\n\nfunction validateFieldName(fieldName) {\n  (0, import_outvariant2.invariant)(fieldName.trim() !== \"\", devUtils.formatMessage(\"Failed to set a custom field on a GraphQL response: field name cannot be empty.\"));\n  (0, import_outvariant2.invariant)(fieldName !== \"data\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?', fieldName));\n  (0, import_outvariant2.invariant)(fieldName !== \"errors\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?', fieldName));\n  (0, import_outvariant2.invariant)(fieldName !== \"extensions\", devUtils.formatMessage('Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?', fieldName));\n} // src/utils/internal/tryCatch.ts\n\n\nfunction tryCatch(fn, onException) {\n  try {\n    const result = fn();\n    return result;\n  } catch (error2) {\n    onException == null ? void 0 : onException(error2);\n  }\n} // src/handlers/GraphQLHandler.ts\n\n\nvar graphqlContext = __spreadProps(__spreadValues({}, defaultContext), {\n  data,\n  extensions,\n  errors,\n  cookie,\n  field\n});\n\nfunction isDocumentNode(value) {\n  if (value == null) {\n    return false;\n  }\n\n  return typeof value === \"object\" && \"kind\" in value && \"definitions\" in value;\n}\n\nvar GraphQLRequest = class extends MockedRequest {\n  constructor(request, variables) {\n    super(request.url, __spreadProps(__spreadValues({}, request), {\n      body: request[\"_body\"]\n    }));\n    this.variables = variables;\n  }\n\n};\nvar GraphQLHandler = class extends RequestHandler {\n  constructor(operationType, operationName, endpoint, resolver) {\n    let resolvedOperationName = operationName;\n\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName);\n\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`);\n      }\n\n      if (!parsedNode.operationName) {\n        throw new Error(`Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`);\n      }\n\n      resolvedOperationName = parsedNode.operationName;\n    }\n\n    const header = operationType === \"all\" ? `${operationType} (origin: ${endpoint.toString()})` : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`;\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName\n      },\n      ctx: graphqlContext,\n      resolver\n    });\n    this.endpoint = endpoint;\n  }\n\n  parse(request) {\n    return tryCatch(() => parseGraphQLRequest(request), error2 => console.error(error2.message));\n  }\n\n  getPublicRequest(request, parsedResult) {\n    return new GraphQLRequest(request, (parsedResult == null ? void 0 : parsedResult.variables) || {});\n  }\n\n  predicate(request, parsedResult) {\n    if (!parsedResult) {\n      return false;\n    }\n\n    if (!parsedResult.operationName && this.info.operationType !== \"all\") {\n      const publicUrl = getPublicUrlFromRequest(request);\n      devUtils.warn(`Failed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation      `);\n      return false;\n    }\n\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint);\n    const hasMatchingOperationType = this.info.operationType === \"all\" || parsedResult.operationType === this.info.operationType;\n    const hasMatchingOperationName = this.info.operationName instanceof RegExp ? this.info.operationName.test(parsedResult.operationName || \"\") : parsedResult.operationName === this.info.operationName;\n    return hasMatchingUrl.matches && hasMatchingOperationType && hasMatchingOperationName;\n  }\n\n  log(request, response2, parsedRequest) {\n    const loggedRequest = prepareRequest(request);\n    const loggedResponse = prepareResponse(response2);\n    const statusColor = getStatusCodeColor(response2.status);\n    const requestInfo = (parsedRequest == null ? void 0 : parsedRequest.operationName) ? `${parsedRequest == null ? void 0 : parsedRequest.operationType} ${parsedRequest == null ? void 0 : parsedRequest.operationName}` : `anonymous ${parsedRequest == null ? void 0 : parsedRequest.operationType}`;\n    console.groupCollapsed(devUtils.formatMessage(\"%s %s (%c%s%c)\"), getTimestamp(), `${requestInfo}`, `color:${statusColor}`, `${response2.status} ${response2.statusText}`, \"color:inherit\");\n    console.log(\"Request:\", loggedRequest);\n    console.log(\"Handler:\", this);\n    console.log(\"Response:\", loggedResponse);\n    console.groupEnd();\n  }\n\n}; // src/utils/request/onUnhandledRequest.ts\n\nvar MAX_MATCH_SCORE = 3;\nvar MAX_SUGGESTION_COUNT = 4;\nvar TYPE_MATCH_DELTA = 0.5;\n\nfunction groupHandlersByType(handlers) {\n  return handlers.reduce((groups, handler) => {\n    if (handler instanceof RestHandler) {\n      groups.rest.push(handler);\n    }\n\n    if (handler instanceof GraphQLHandler) {\n      groups.graphql.push(handler);\n    }\n\n    return groups;\n  }, {\n    rest: [],\n    graphql: []\n  });\n}\n\nfunction getRestHandlerScore() {\n  return (request, handler) => {\n    const {\n      path,\n      method\n    } = handler.info;\n\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity;\n    }\n\n    const hasSameMethod = isStringEqual(request.method, method);\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0;\n    const requestPublicUrl = getPublicUrlFromRequest(request);\n    const score = (0, import_js_levenshtein.default)(requestPublicUrl, path);\n    return score - methodScoreDelta;\n  };\n}\n\nfunction getGraphQLHandlerScore(parsedQuery) {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === \"undefined\") {\n      return Infinity;\n    }\n\n    const {\n      operationType,\n      operationName\n    } = handler.info;\n\n    if (typeof operationName !== \"string\") {\n      return Infinity;\n    }\n\n    const hasSameOperationType = parsedQuery.operationType === operationType;\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0;\n    const score = (0, import_js_levenshtein.default)(parsedQuery.operationName, operationName);\n    return score - operationTypeScoreDelta;\n  };\n}\n\nfunction getSuggestedHandler(request, handlers, getScore) {\n  const suggestedHandlers = handlers.reduce((suggestions, handler) => {\n    const score = getScore(request, handler);\n    return suggestions.concat([[score, handler]]);\n  }, []).sort((_ref3, _ref4) => {\n    let [leftScore] = _ref3;\n    let [rightScore] = _ref4;\n    return leftScore - rightScore;\n  }).filter(_ref5 => {\n    let [score] = _ref5;\n    return score <= MAX_MATCH_SCORE;\n  }).slice(0, MAX_SUGGESTION_COUNT).map(_ref6 => {\n    let [, handler] = _ref6;\n    return handler;\n  });\n  return suggestedHandlers;\n}\n\nfunction getSuggestedHandlersMessage(handlers) {\n  if (handlers.length > 1) {\n    return `Did you mean to request one of the following resources instead?\n\n${handlers.map(handler => `  \\u2022 ${handler.info.header}`).join(\"\\n\")}`;\n  }\n\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`;\n}\n\nfunction onUnhandledRequest(request, handlers) {\n  let strategy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"warn\";\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request));\n\n  function generateHandlerSuggestion() {\n    const handlerGroups = groupHandlersByType(handlers);\n    const relevantHandlers = parsedGraphQLQuery ? handlerGroups.graphql : handlerGroups.rest;\n    const suggestedHandlers = getSuggestedHandler(request, relevantHandlers, parsedGraphQLQuery ? getGraphQLHandlerScore(parsedGraphQLQuery) : getRestHandlerScore());\n    return suggestedHandlers.length > 0 ? getSuggestedHandlersMessage(suggestedHandlers) : \"\";\n  }\n\n  function generateUnhandledRequestMessage() {\n    const publicUrl = getPublicUrlFromRequest(request);\n    const requestHeader = parsedGraphQLQuery ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})` : `${request.method} ${publicUrl}`;\n    const handlerSuggestion = generateHandlerSuggestion();\n    const messageTemplate = [`captured a request without a matching request handler:`, `  \\u2022 ${requestHeader}`, handlerSuggestion, `If you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks`].filter(Boolean);\n    return messageTemplate.join(\"\\n\\n\");\n  }\n\n  function applyStrategy(strategy2) {\n    const message = generateUnhandledRequestMessage();\n\n    switch (strategy2) {\n      case \"error\":\n        {\n          devUtils.error(\"Error: %s\", message);\n          throw new Error(devUtils.formatMessage('Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.'));\n        }\n\n      case \"warn\":\n        {\n          devUtils.warn(\"Warning: %s\", message);\n          break;\n        }\n\n      case \"bypass\":\n        break;\n\n      default:\n        throw new Error(devUtils.formatMessage('Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.', strategy2));\n    }\n  }\n\n  if (typeof strategy === \"function\") {\n    strategy(request, {\n      warning: applyStrategy.bind(null, \"warn\"),\n      error: applyStrategy.bind(null, \"error\")\n    });\n    return;\n  }\n\n  applyStrategy(strategy);\n} // src/utils/request/readResponseCookies.ts\n\n\nvar import_cookies2 = require(\"@mswjs/cookies\");\n\nfunction readResponseCookies(request, response2) {\n  import_cookies2.store.add(__spreadProps(__spreadValues({}, request), {\n    url: request.url.toString()\n  }), response2);\n  import_cookies2.store.persist();\n} // src/utils/handleRequest.ts\n\n\nasync function handleRequest(request, handlers, options, emitter, handleRequestOptions) {\n  var _a, _b, _c, _d, _e, _f;\n\n  emitter.emit(\"request:start\", request);\n\n  if (request.headers.get(\"x-msw-bypass\") === \"true\") {\n    emitter.emit(\"request:end\", request);\n    (_a = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _a.call(handleRequestOptions, request);\n    return;\n  }\n\n  const [lookupError, lookupResult] = await (0, import_until2.until)(() => {\n    return getResponse(request, handlers, handleRequestOptions == null ? void 0 : handleRequestOptions.resolutionContext);\n  });\n\n  if (lookupError) {\n    emitter.emit(\"unhandledException\", lookupError, request);\n    throw lookupError;\n  }\n\n  const {\n    handler,\n    response: response2\n  } = lookupResult;\n\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest);\n    emitter.emit(\"request:unhandled\", request);\n    emitter.emit(\"request:end\", request);\n    (_b = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _b.call(handleRequestOptions, request);\n    return;\n  }\n\n  if (!response2) {\n    devUtils.warn(`Expected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\n\n  \\u2022 %s\n    %s`, response2, handler.info.header, handler.info.callFrame);\n    emitter.emit(\"request:end\", request);\n    (_c = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _c.call(handleRequestOptions, request);\n    return;\n  }\n\n  if (response2.passthrough) {\n    emitter.emit(\"request:end\", request);\n    (_d = handleRequestOptions == null ? void 0 : handleRequestOptions.onPassthroughResponse) == null ? void 0 : _d.call(handleRequestOptions, request);\n    return;\n  }\n\n  readResponseCookies(request, response2);\n  emitter.emit(\"request:match\", request);\n  const requiredLookupResult = lookupResult;\n  const transformedResponse = ((_e = handleRequestOptions == null ? void 0 : handleRequestOptions.transformResponse) == null ? void 0 : _e.call(handleRequestOptions, response2)) || response2;\n  (_f = handleRequestOptions == null ? void 0 : handleRequestOptions.onMockedResponse) == null ? void 0 : _f.call(handleRequestOptions, transformedResponse, requiredLookupResult);\n  emitter.emit(\"request:end\", request);\n  return transformedResponse;\n} // src/utils/logging/serializeResponse.ts\n\n\nvar import_headers_polyfill9 = require(\"headers-polyfill\");\n\nfunction serializeResponse(source) {\n  return {\n    status: source.status,\n    statusText: source.statusText,\n    headers: (0, import_headers_polyfill9.flattenHeadersObject)((0, import_headers_polyfill9.headersToObject)(source.headers)),\n    body: source.body\n  };\n} // src/setupWorker/start/createRequestListener.ts\n\n\nvar createRequestListener = (context, options) => {\n  return async (event, message) => {\n    const messageChannel = new WorkerChannel(event.ports[0]);\n    const request = parseWorkerRequest(message.payload);\n\n    try {\n      await handleRequest(request, context.requestHandlers, options, context.emitter, {\n        transformResponse,\n\n        onPassthroughResponse() {\n          messageChannel.postMessage(\"NOT_FOUND\");\n        },\n\n        async onMockedResponse(response2, _ref7) {\n          let {\n            handler,\n            publicRequest,\n            parsedRequest\n          } = _ref7;\n\n          if (response2.body instanceof ReadableStream) {\n            throw new Error(devUtils.formatMessage('Failed to construct a mocked response with a \"ReadableStream\" body: mocked streams are not supported. Follow https://github.com/mswjs/msw/issues/1336 for more details.'));\n          }\n\n          const responseInstance = new Response(response2.body, response2);\n          const responseBodyBuffer = await responseInstance.arrayBuffer();\n          const responseBody = response2.body == null ? null : responseBodyBuffer;\n          messageChannel.postMessage(\"MOCK_RESPONSE\", __spreadProps(__spreadValues({}, response2), {\n            body: responseBody\n          }), [responseBodyBuffer]);\n\n          if (!options.quiet) {\n            context.emitter.once(\"response:mocked\", response3 => {\n              handler.log(publicRequest, serializeResponse(response3), parsedRequest);\n            });\n          }\n        }\n\n      });\n    } catch (error2) {\n      if (error2 instanceof NetworkError) {\n        messageChannel.postMessage(\"NETWORK_ERROR\", {\n          name: error2.name,\n          message: error2.message\n        });\n        return;\n      }\n\n      if (error2 instanceof Error) {\n        devUtils.error(`Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`, request.method, request.url, error2);\n        messageChannel.postMessage(\"MOCK_RESPONSE\", {\n          status: 500,\n          statusText: \"Request Handler Error\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          body: JSON.stringify({\n            name: error2.name,\n            message: error2.message,\n            stack: error2.stack\n          })\n        });\n      }\n    }\n  };\n};\n\nfunction transformResponse(response2) {\n  return {\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: response2.headers.all(),\n    body: response2.body,\n    delay: response2.delay\n  };\n} // src/utils/internal/requestIntegrityCheck.ts\n\n\nasync function requestIntegrityCheck(context, serviceWorker) {\n  context.workerChannel.send(\"INTEGRITY_CHECK_REQUEST\");\n  const {\n    payload: actualChecksum\n  } = await context.events.once(\"INTEGRITY_CHECK_RESPONSE\");\n\n  if (actualChecksum !== \"b3066ef78c2f9090b4ce87e874965995\") {\n    throw new Error(`Currently active Service Worker (${actualChecksum}) is behind the latest published one (${\"b3066ef78c2f9090b4ce87e874965995\"}).`);\n  }\n\n  return serviceWorker;\n} // src/utils/deferNetworkRequestsUntil.ts\n\n\nvar import_until3 = require(\"@open-draft/until\");\n\nfunction deferNetworkRequestsUntil(predicatePromise) {\n  const originalXhrSend = window.XMLHttpRequest.prototype.send;\n\n  window.XMLHttpRequest.prototype.send = function () {\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n\n    (0, import_until3.until)(() => predicatePromise).then(() => {\n      window.XMLHttpRequest.prototype.send = originalXhrSend;\n      this.send(...args);\n    });\n  };\n\n  const originalFetch = window.fetch;\n\n  window.fetch = async function () {\n    await (0, import_until3.until)(() => predicatePromise);\n    window.fetch = originalFetch;\n    return window.fetch(...arguments);\n  };\n} // src/setupWorker/start/createResponseListener.ts\n\n\nfunction createResponseListener(context) {\n  return (_, message) => {\n    var _a;\n\n    const {\n      payload: responseJson\n    } = message;\n\n    if ((_a = responseJson.type) == null ? void 0 : _a.includes(\"opaque\")) {\n      return;\n    }\n\n    const response2 = new Response(responseJson.body || null, responseJson);\n    const isMockedResponse = response2.headers.get(\"x-powered-by\") === \"msw\";\n\n    if (isMockedResponse) {\n      context.emitter.emit(\"response:mocked\", response2, responseJson.requestId);\n    } else {\n      context.emitter.emit(\"response:bypass\", response2, responseJson.requestId);\n    }\n  };\n} // src/setupWorker/start/utils/validateWorkerScope.ts\n\n\nfunction validateWorkerScope(registration, options) {\n  if (!(options == null ? void 0 : options.quiet) && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(`Cannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.`);\n  }\n} // src/setupWorker/start/createStartHandler.ts\n\n\nvar createStartHandler = context => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      context.events.removeAllListeners();\n      context.workerChannel.on(\"REQUEST\", createRequestListener(context, options));\n      context.workerChannel.on(\"RESPONSE\", createResponseListener(context));\n      const instance = await getWorkerInstance(options.serviceWorker.url, options.serviceWorker.options, options.findWorker);\n      const [worker, registration] = instance;\n\n      if (!worker) {\n        const missingWorkerMessage = (customOptions == null ? void 0 : customOptions.findWorker) ? devUtils.formatMessage(`Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`, options.serviceWorker.url) : devUtils.formatMessage(`Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`, options.serviceWorker.url, location.host);\n        throw new Error(missingWorkerMessage);\n      }\n\n      context.worker = worker;\n      context.registration = registration;\n      context.events.addListener(window, \"beforeunload\", () => {\n        if (worker.state !== \"redundant\") {\n          context.workerChannel.send(\"CLIENT_CLOSED\");\n        }\n\n        window.clearInterval(context.keepAliveInterval);\n      });\n      const [integrityError] = await (0, import_until4.until)(() => requestIntegrityCheck(context, worker));\n\n      if (integrityError) {\n        devUtils.error(`Detected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues      `);\n      }\n\n      context.keepAliveInterval = window.setInterval(() => context.workerChannel.send(\"KEEPALIVE_REQUEST\"), 5e3);\n      validateWorkerScope(registration, context.startOptions);\n      return registration;\n    };\n\n    const workerRegistration = startWorkerInstance().then(async registration => {\n      const pendingInstance = registration.installing || registration.waiting;\n\n      if (pendingInstance) {\n        await new Promise(resolve => {\n          pendingInstance.addEventListener(\"statechange\", () => {\n            if (pendingInstance.state === \"activated\") {\n              return resolve();\n            }\n          });\n        });\n      }\n\n      await enableMocking(context, options).catch(error2 => {\n        throw new Error(`Failed to enable mocking: ${error2 == null ? void 0 : error2.message}`);\n      });\n      return registration;\n    });\n\n    if (options.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration);\n    }\n\n    return workerRegistration;\n  };\n}; // src/setupWorker/stop/utils/printStopMessage.ts\n\n\nfunction printStopMessage() {\n  let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (args.quiet) {\n    return;\n  }\n\n  console.log(`%c${devUtils.formatMessage(\"Mocking disabled.\")}`, \"color:orangered;font-weight:bold;\");\n} // src/setupWorker/stop/createStop.ts\n\n\nvar createStop = context => {\n  return function stop() {\n    var _a;\n\n    if (!context.isMockingEnabled) {\n      devUtils.warn('Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.');\n      return;\n    }\n\n    context.workerChannel.send(\"MOCK_DEACTIVATE\");\n    context.isMockingEnabled = false;\n    window.clearInterval(context.keepAliveInterval);\n    printStopMessage({\n      quiet: (_a = context.startOptions) == null ? void 0 : _a.quiet\n    });\n  };\n}; // src/utils/internal/requestHandlerUtils.ts\n\n\nfunction use(currentHandlers) {\n  for (var _len9 = arguments.length, handlers = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n    handlers[_key9 - 1] = arguments[_key9];\n  }\n\n  currentHandlers.unshift(...handlers);\n}\n\nfunction restoreHandlers(handlers) {\n  handlers.forEach(handler => {\n    handler.markAsSkipped(false);\n  });\n}\n\nfunction resetHandlers(initialHandlers) {\n  for (var _len10 = arguments.length, nextHandlers = new Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\n    nextHandlers[_key10 - 1] = arguments[_key10];\n  }\n\n  return nextHandlers.length > 0 ? [...nextHandlers] : [...initialHandlers];\n} // src/setupWorker/start/utils/prepareStartHandler.ts\n\n\nvar DEFAULT_START_OPTIONS = {\n  serviceWorker: {\n    url: \"/mockServiceWorker.js\",\n    options: null\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: \"warn\",\n\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl;\n  }\n\n};\n\nfunction resolveStartOptions(initialOptions) {\n  return mergeRight(DEFAULT_START_OPTIONS, initialOptions || {});\n}\n\nfunction prepareStartHandler(handler, context) {\n  return initialOptions => {\n    context.startOptions = resolveStartOptions(initialOptions);\n    return handler(context.startOptions, initialOptions || {});\n  };\n} // src/setupWorker/start/createFallbackRequestListener.ts\n\n\nvar import_interceptors4 = require(\"@mswjs/interceptors\");\n\nvar import_fetch3 = require(\"@mswjs/interceptors/lib/interceptors/fetch\");\n\nvar import_XMLHttpRequest = require(\"@mswjs/interceptors/lib/interceptors/XMLHttpRequest\"); // src/utils/request/createResponseFromIsomorphicResponse.ts\n\n\nvar import_interceptors3 = require(\"@mswjs/interceptors\");\n\nvar noop = () => {\n  throw new Error(\"Not implemented\");\n};\n\nfunction createResponseFromIsomorphicResponse(response2) {\n  return __spreadProps(__spreadValues({}, response2), {\n    ok: response2.status >= 200 && response2.status < 300,\n    url: \"\",\n    type: \"default\",\n    status: response2.status,\n    statusText: response2.statusText,\n    headers: response2.headers,\n    body: new ReadableStream(),\n    redirected: response2.headers.get(\"Location\") != null,\n\n    async text() {\n      return response2.body || \"\";\n    },\n\n    async json() {\n      return JSON.parse(response2.body || \"\");\n    },\n\n    async arrayBuffer() {\n      return (0, import_interceptors3.encodeBuffer)(response2.body || \"\");\n    },\n\n    bodyUsed: false,\n    formData: noop,\n    blob: noop,\n    clone: noop\n  });\n} // src/setupWorker/start/createFallbackRequestListener.ts\n\n\nfunction createFallbackRequestListener(context, options) {\n  const interceptor = new import_interceptors4.BatchInterceptor({\n    name: \"fallback\",\n    interceptors: [new import_fetch3.FetchInterceptor(), new import_XMLHttpRequest.XMLHttpRequestInterceptor()]\n  });\n  interceptor.on(\"request\", async request => {\n    const mockedRequest = new MockedRequest(request.url, __spreadProps(__spreadValues({}, request), {\n      body: await request.arrayBuffer()\n    }));\n    const response2 = await handleRequest(mockedRequest, context.requestHandlers, options, context.emitter, {\n      transformResponse(response3) {\n        return {\n          status: response3.status,\n          statusText: response3.statusText,\n          headers: response3.headers.all(),\n          body: response3.body,\n          delay: response3.delay\n        };\n      },\n\n      onMockedResponse(_, _ref8) {\n        let {\n          handler,\n          publicRequest,\n          parsedRequest\n        } = _ref8;\n\n        if (!options.quiet) {\n          context.emitter.once(\"response:mocked\", response3 => {\n            handler.log(publicRequest, serializeResponse(response3), parsedRequest);\n          });\n        }\n      }\n\n    });\n\n    if (response2) {\n      request.respondWith(response2);\n    }\n  });\n  interceptor.on(\"response\", (request, response2) => {\n    if (!request.id) {\n      return;\n    }\n\n    const browserResponse = createResponseFromIsomorphicResponse(response2);\n\n    if (response2.headers.get(\"x-powered-by\") === \"msw\") {\n      context.emitter.emit(\"response:mocked\", browserResponse, request.id);\n    } else {\n      context.emitter.emit(\"response:bypass\", browserResponse, request.id);\n    }\n  });\n  interceptor.apply();\n  return interceptor;\n} // src/setupWorker/start/createFallbackStart.ts\n\n\nfunction createFallbackStart(context) {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(context, options);\n    printStartMessage({\n      message: \"Mocking enabled (fallback mode).\",\n      quiet: options.quiet\n    });\n    return void 0;\n  };\n} // src/setupWorker/stop/createFallbackStop.ts\n\n\nfunction createFallbackStop(context) {\n  return function stop() {\n    var _a, _b;\n\n    (_a = context.fallbackInterceptor) == null ? void 0 : _a.dispose();\n    printStopMessage({\n      quiet: (_b = context.startOptions) == null ? void 0 : _b.quiet\n    });\n  };\n} // src/utils/internal/pipeEvents.ts\n\n\nfunction pipeEvents(source, destination) {\n  const rawEmit = source.emit;\n\n  if (rawEmit._isPiped) {\n    return;\n  }\n\n  source.emit = function (event) {\n    for (var _len11 = arguments.length, data2 = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n      data2[_key11 - 1] = arguments[_key11];\n    }\n\n    destination.emit(event, ...data2);\n    return rawEmit.call(this, event, ...data2);\n  };\n\n  source.emit._isPiped = true;\n} // src/utils/internal/toReadonlyArray.ts\n\n\nfunction toReadonlyArray(source) {\n  const clone = [...source];\n  Object.freeze(clone);\n  return clone;\n} // src/setupWorker/setupWorker.ts\n\n\nvar listeners = [];\n\nfunction setupWorker() {\n  for (var _len12 = arguments.length, requestHandlers = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {\n    requestHandlers[_key12] = arguments[_key12];\n  }\n\n  requestHandlers.forEach(handler => {\n    if (Array.isArray(handler)) throw new Error(devUtils.formatMessage('Failed to call \"setupWorker\" given an Array of request handlers (setupWorker([a, b])), expected to receive each handler individually: setupWorker(a, b).'));\n  });\n\n  if ((0, import_is_node_process3.isNodeProcess)()) {\n    throw new Error(devUtils.formatMessage(\"Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.\"));\n  }\n\n  const emitter = new import_strict_event_emitter.StrictEventEmitter();\n  const publicEmitter = new import_strict_event_emitter.StrictEventEmitter();\n  pipeEvents(emitter, publicEmitter);\n  const context = {\n    isMockingEnabled: false,\n    startOptions: void 0,\n    worker: null,\n    registration: null,\n    requestHandlers: [...requestHandlers],\n    emitter,\n    workerChannel: {\n      on(eventType, callback) {\n        context.events.addListener(navigator.serviceWorker, \"message\", event => {\n          if (event.source !== context.worker) {\n            return;\n          }\n\n          const message = event.data;\n\n          if (!message) {\n            return;\n          }\n\n          if (message.type === eventType) {\n            callback(event, message);\n          }\n        });\n      },\n\n      send(type) {\n        var _a;\n\n        (_a = context.worker) == null ? void 0 : _a.postMessage(type);\n      }\n\n    },\n    events: {\n      addListener(target, eventType, callback) {\n        target.addEventListener(eventType, callback);\n        listeners.push({\n          eventType,\n          target,\n          callback\n        });\n        return () => {\n          target.removeEventListener(eventType, callback);\n        };\n      },\n\n      removeAllListeners() {\n        for (const {\n          target,\n          eventType,\n          callback\n        } of listeners) {\n          target.removeEventListener(eventType, callback);\n        }\n\n        listeners = [];\n      },\n\n      once(eventType) {\n        const bindings = [];\n        return new Promise((resolve, reject) => {\n          const handleIncomingMessage = event => {\n            try {\n              const message = event.data;\n\n              if (message.type === eventType) {\n                resolve(message);\n              }\n            } catch (error2) {\n              reject(error2);\n            }\n          };\n\n          bindings.push(context.events.addListener(navigator.serviceWorker, \"message\", handleIncomingMessage), context.events.addListener(navigator.serviceWorker, \"messageerror\", reject));\n        }).finally(() => {\n          bindings.forEach(unbind => unbind());\n        });\n      }\n\n    },\n    useFallbackMode: !(\"serviceWorker\" in navigator) || location.protocol === \"file:\"\n  };\n  const startHandler = context.useFallbackMode ? createFallbackStart(context) : createStartHandler(context);\n  const stopHandler = context.useFallbackMode ? createFallbackStop(context) : createStop(context);\n  return {\n    start: prepareStartHandler(startHandler, context),\n\n    stop() {\n      context.events.removeAllListeners();\n      context.emitter.removeAllListeners();\n      publicEmitter.removeAllListeners();\n      stopHandler();\n    },\n\n    use() {\n      for (var _len13 = arguments.length, handlers = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {\n        handlers[_key13] = arguments[_key13];\n      }\n\n      use(context.requestHandlers, ...handlers);\n    },\n\n    restoreHandlers() {\n      restoreHandlers(context.requestHandlers);\n    },\n\n    resetHandlers() {\n      for (var _len14 = arguments.length, nextHandlers = new Array(_len14), _key14 = 0; _key14 < _len14; _key14++) {\n        nextHandlers[_key14] = arguments[_key14];\n      }\n\n      context.requestHandlers = resetHandlers(requestHandlers, ...nextHandlers);\n    },\n\n    listHandlers() {\n      return toReadonlyArray(context.requestHandlers);\n    },\n\n    printHandlers() {\n      const handlers = this.listHandlers();\n      handlers.forEach(handler => {\n        const {\n          header,\n          callFrame\n        } = handler.info;\n        const pragma = handler.info.hasOwnProperty(\"operationType\") ? \"[graphql]\" : \"[rest]\";\n        console.groupCollapsed(`${pragma} ${header}`);\n\n        if (callFrame) {\n          console.log(`Declaration: ${callFrame}`);\n        }\n\n        console.log(\"Handler:\", handler);\n\n        if (handler instanceof RestHandler) {\n          console.log(\"Match:\", `https://mswjs.io/repl?path=${handler.info.path}`);\n        }\n\n        console.groupEnd();\n      });\n    },\n\n    events: {\n      on() {\n        return publicEmitter.on(...arguments);\n      },\n\n      removeListener() {\n        return publicEmitter.removeListener(...arguments);\n      },\n\n      removeAllListeners() {\n        return publicEmitter.removeAllListeners(...arguments);\n      }\n\n    }\n  };\n} // src/rest.ts\n\n\nfunction createRestHandler(method) {\n  return (path, resolver) => {\n    return new RestHandler(method, path, resolver);\n  };\n}\n\nvar rest = {\n  all: createRestHandler(/.+/),\n  head: createRestHandler(\"HEAD\"\n  /* HEAD */\n  ),\n  get: createRestHandler(\"GET\"\n  /* GET */\n  ),\n  post: createRestHandler(\"POST\"\n  /* POST */\n  ),\n  put: createRestHandler(\"PUT\"\n  /* PUT */\n  ),\n  delete: createRestHandler(\"DELETE\"\n  /* DELETE */\n  ),\n  patch: createRestHandler(\"PATCH\"\n  /* PATCH */\n  ),\n  options: createRestHandler(\"OPTIONS\"\n  /* OPTIONS */\n  )\n}; // src/graphql.ts\n\nfunction createScopedGraphQLHandler(operationType, url) {\n  return (operationName, resolver) => {\n    return new GraphQLHandler(operationType, operationName, url, resolver);\n  };\n}\n\nfunction createGraphQLOperationHandler(url) {\n  return resolver => {\n    return new GraphQLHandler(\"all\", new RegExp(\".*\"), url, resolver);\n  };\n}\n\nvar standardGraphQLHandlers = {\n  operation: createGraphQLOperationHandler(\"*\"),\n  query: createScopedGraphQLHandler(\"query\", \"*\"),\n  mutation: createScopedGraphQLHandler(\"mutation\", \"*\")\n};\n\nfunction createGraphQLLink(url) {\n  return {\n    operation: createGraphQLOperationHandler(url),\n    query: createScopedGraphQLHandler(\"query\", url),\n    mutation: createScopedGraphQLHandler(\"mutation\", url)\n  };\n}\n\nvar graphql = __spreadProps(__spreadValues({}, standardGraphQLHandlers), {\n  link: createGraphQLLink\n}); // Annotate the CommonJS export names for ESM import in node:\n\n\n0 && (module.exports = {\n  GraphQLHandler,\n  MockedRequest,\n  RESTMethods,\n  RequestHandler,\n  RestHandler,\n  cleanUrl,\n  compose,\n  context,\n  createResponseComposition,\n  defaultContext,\n  defaultResponse,\n  graphql,\n  graphqlContext,\n  handleRequest,\n  matchRequestUrl,\n  response,\n  rest,\n  restContext,\n  setupWorker\n});","map":{"version":3,"mappings":"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","names":["__export","GraphQLHandler","MockedRequest","RESTMethods","RequestHandler","RestHandler","cleanUrl","compose","context","createResponseComposition","defaultContext","defaultResponse","graphql","graphqlContext","handleRequest","matchRequestUrl","response","rest","restContext","setupWorker","module","body","cookie","data","delay","errors","extensions","fetch","json","set","status","text","xml","__toESM","statusCode","statusText","res","import_codes","String","require","args","name","value","headers","append","forEach","value2","name2","options","serializedCookie","cookieUtils","document","JSON","parse","error2","Array","isArray","left","right","Object","entries","reduce","result","key","rightValue","leftValue","concat","isObject","mergeRight","assign","body2","stringify","payload","prevBody","jsonParse","nextBody","SET_TIMEOUT_MAX_ALLOWED_INT","MIN_SERVER_RESPONSE_TIME","MAX_SERVER_RESPONSE_TIME","NODE_SERVER_RESPONSE_TIME","getRandomServerResponseTime","Math","floor","random","durationOrMode","delayTime","Error","errorsList","useFetch","window","augmentRequestInit","requestInit","import_headers_polyfill2","__spreadProps","all","createFetchRequestParameters","input","method","requestParameters","includes","derivedRequestInit","url","href","getWorkerByRegistration","registration","absoluteWorkerUrl","findWorker","allStates","active","installing","waiting","existingStates","filter","Boolean","mockWorker","find","worker","scriptURL","relativeUrl","URL","location","origin","LIBRARY_PREFIX","message","positionals","interpolatedMessage","console","warn","formatMessage","error","devUtils","getWorkerInstance","getAbsoluteWorkerUrl","mockRegistrations","navigator","serviceWorker","getRegistrations","then","registrations","controller","length","reload","existingRegistration","update","instance","register","isWorkerMissing","scopeUrl","scope","quiet","groupCollapsed","log","workerUrl","workerScope","groupEnd","workerChannel","send","events","once","isMockingEnabled","printStartMessage","constructor","port","postMessage","event","rest2","data2","transfer","type","cookieUtils2","request","credentials","getAllCookies","headersString","contentType","get","disposition","directives","split","acc","chunk","trim","join","slice","filename","boundary","d","startsWith","map","s","replace","boundaryRegExp","RegExp","fields","endsWith","trimStart","parsedBody","field2","contentHeaders","contentBody","parseContentHeaders","File","contentType2","parsedValue","toLowerCase","hasMultipartContent","parseMultipartData","toString","hasJsonContent","actual","expected","import_interceptors","init","id","cache","destination","integrity","keepalive","mode","priority","redirect","referrer","referrerPolicy","cookies","getCookies","text2","parseBody","isStringEqual","passthrough","import_headers_polyfill4","requestCookiesString","ownCookies","cookieUtils3","import_cookies","hydrate","cookiesFromStore","from","cookiesFromDocument","getRequestCookies","forwardedCookies","__spreadValues","rawRequest","import_headers_polyfill5","getResponse","handlers","resolutionContext","relevantHandlers","handler","test","executionResult","previousResults","result2","run","shouldSkip","parsedResult","markAsSkipped","Promise","resolve","publicRequest","parsedRequest","getPublicUrlFromRequest","pathname","protocol","host","node","operationDef","definitions","def","kind","operationType","operation","operationName","query","ast","parseDocumentNode","variables","files","operations","pathArray","dotPath","lastPath","reversedPaths","reverse","paths","target","path","searchParams","_c","parsedOperations","parsedMap","extractMultipartVariables","getGraphQLInput","parseQuery","requestPublicUrl","status2","now","Date","getHours","getMinutes","getSeconds","padStart","responseHeaders","REDUNDANT_CHARACTERS_EXP","baseUrl","isAbsoluteUrl","baseURI","decodeURI","encodeURI","maybeAbsoluteUrl","getAbsoluteUrl","_","parameterName","wildcard","expression","normalizedPath","normalizePath","cleanPath","coercePath","cleanUrl2","decode","decodeURIComponent","params","matches","fns","reduceRight","leftFn","rightFn","defaultResponseTransformers","responseOverrides","defaultTransformers","initialResponse","import_headers_polyfill7","transformers","resolvedTransformers","resolvedResponse","networkError","NetworkError","SOURCE_FRAME","BUILD_FRAME","stack","frames","declarationFrame","frame","declarationPath","fn","Symbol","iterator","ctx","resolver","callFrame","getCallFrame","info","_request","_resolutionContext","predicate","getPublicRequest","_parsedResult","shouldIntercept","executeResolver","wrapResolver","mockedResponse","createExecutionResult","req","resolverGenerator","isIterable","done","next","nextResponse","resolverGeneratorResult","response2","RESTMethods2","header","checkRedundantQueryParameters","getSearchParams","queryParams","paramName","push","RestRequest","matchesMethod","publicUrl","loggedRequest","prepareRequest","loggedResponse","prepareResponse","statusColor","getStatusCodeColor","getTimestamp","field","fieldName","fieldValue","validateFieldName","onException","endpoint","resolvedOperationName","isDocumentNode","parsedNode","tryCatch","parseGraphQLRequest","GraphQLRequest","hasMatchingUrl","hasMatchingOperationType","hasMatchingOperationName","requestInfo","MAX_MATCH_SCORE","MAX_SUGGESTION_COUNT","TYPE_MATCH_DELTA","groups","Infinity","hasSameMethod","methodScoreDelta","score","parsedQuery","hasSameOperationType","operationTypeScoreDelta","getScore","suggestedHandlers","suggestions","sort","leftScore","rightScore","strategy","parsedGraphQLQuery","handlerGroups","groupHandlersByType","getSuggestedHandler","getGraphQLHandlerScore","getRestHandlerScore","getSuggestedHandlersMessage","requestHeader","handlerSuggestion","generateHandlerSuggestion","messageTemplate","strategy2","generateUnhandledRequestMessage","warning","applyStrategy","bind","import_cookies2","add","persist","emitter","handleRequestOptions","emit","onPassthroughResponse","lookupError","lookupResult","onUnhandledRequest","readResponseCookies","requiredLookupResult","transformedResponse","transformResponse","onMockedResponse","source","createRequestListener","messageChannel","WorkerChannel","ports","parseWorkerRequest","requestHandlers","ReadableStream","responseInstance","Response","responseBodyBuffer","arrayBuffer","responseBody","response3","serializeResponse","actualChecksum","predicatePromise","originalXhrSend","XMLHttpRequest","prototype","originalFetch","responseJson","isMockedResponse","requestId","createStartHandler","customOptions","startWorkerInstance","removeAllListeners","on","createResponseListener","missingWorkerMessage","addListener","state","clearInterval","keepAliveInterval","integrityError","requestIntegrityCheck","setInterval","validateWorkerScope","startOptions","workerRegistration","pendingInstance","addEventListener","enableMocking","catch","waitUntilReady","deferNetworkRequestsUntil","createStop","printStopMessage","currentHandlers","unshift","initialHandlers","nextHandlers","DEFAULT_START_OPTIONS","mockServiceWorkerUrl","initialOptions","resolveStartOptions","noop","ok","redirected","bodyUsed","formData","blob","clone","interceptor","import_interceptors4","interceptors","import_fetch3","import_XMLHttpRequest","mockedRequest","respondWith","browserResponse","createResponseFromIsomorphicResponse","apply","fallbackInterceptor","createFallbackRequestListener","dispose","rawEmit","_isPiped","call","freeze","listeners","import_strict_event_emitter","publicEmitter","pipeEvents","eventType","callback","removeEventListener","bindings","reject","handleIncomingMessage","finally","unbind","useFallbackMode","startHandler","createFallbackStart","stopHandler","createFallbackStop","start","prepareStartHandler","stop","use","restoreHandlers","resetHandlers","listHandlers","toReadonlyArray","printHandlers","pragma","hasOwnProperty","removeListener","createRestHandler","head","post","put","delete","patch","standardGraphQLHandlers","createGraphQLOperationHandler","createScopedGraphQLHandler","mutation","link","createGraphQLLink"],"sources":["C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\index.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\context\\index.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\context\\status.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\context\\set.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\context\\cookie.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\context\\body.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\jsonParse.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\isObject.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\mergeRight.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\context\\json.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\context\\data.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\context\\extensions.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\context\\delay.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\context\\errors.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\context\\fetch.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\context\\text.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\context\\xml.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\setupWorker.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\createStartHandler.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\utils\\getWorkerInstance.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\utils\\getWorkerByRegistration.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\url\\getAbsoluteWorkerUrl.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\devUtils.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\utils\\printStartMessage.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\utils\\enableMocking.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\utils\\createMessageChannel.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\NetworkError.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\request\\parseWorkerRequest.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\request\\MockedRequest.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\request\\getRequestCookies.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\parseMultipartData.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\request\\parseBody.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\isStringEqual.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\handleRequest.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\getResponse.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\request\\onUnhandledRequest.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\parseGraphQLRequest.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\request\\getPublicUrlFromRequest.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\logging\\getStatusCodeColor.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\logging\\getTimestamp.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\logging\\prepareRequest.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\logging\\prepareResponse.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\matching\\matchRequestUrl.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\url\\cleanUrl.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\url\\isAbsoluteUrl.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\url\\getAbsoluteUrl.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\matching\\normalizePath.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\handlers\\RequestHandler.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\response.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\compose.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\getCallFrame.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\isIterable.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\handlers\\RestHandler.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\context\\field.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\tryCatch.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\handlers\\GraphQLHandler.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\request\\readResponseCookies.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\logging\\serializeResponse.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\createRequestListener.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\requestIntegrityCheck.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\deferNetworkRequestsUntil.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\createResponseListener.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\utils\\validateWorkerScope.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\stop\\utils\\printStopMessage.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\stop\\createStop.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\requestHandlerUtils.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\utils\\prepareStartHandler.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\createFallbackRequestListener.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\request\\createResponseFromIsomorphicResponse.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\start\\createFallbackStart.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\setupWorker\\stop\\createFallbackStop.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\pipeEvents.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\utils\\internal\\toReadonlyArray.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\rest.ts","C:\\Users\\nawue\\OneDrive\\Desktop\\exm\\frontend\\fe3-final\\fe3-final-main\\node_modules\\msw\\src\\graphql.ts"],"sourcesContent":["import * as context from './context'\nexport { context }\n\nexport { setupWorker } from './setupWorker/setupWorker'\nexport {\n  response,\n  defaultResponse,\n  createResponseComposition,\n} from './response'\n\n/* Request handlers */\nexport { RequestHandler, defaultContext } from './handlers/RequestHandler'\nexport { rest } from './rest'\nexport { RestHandler, RESTMethods, restContext } from './handlers/RestHandler'\nexport { graphql } from './graphql'\nexport { GraphQLHandler, graphqlContext } from './handlers/GraphQLHandler'\n\n/* Utils */\nexport { matchRequestUrl } from './utils/matching/matchRequestUrl'\nexport { compose } from './utils/internal/compose'\nexport * from './utils/handleRequest'\nexport { cleanUrl } from './utils/url/cleanUrl'\n\n/**\n * Type definitions.\n */\nexport type { SetupWorkerApi, StartOptions } from './setupWorker/glossary'\nexport type { SharedOptions } from './sharedOptions'\n\nexport * from './utils/request/MockedRequest'\nexport type {\n  ResponseResolver,\n  ResponseResolverReturnType,\n  AsyncResponseResolverReturnType,\n  DefaultBodyType,\n  DefaultRequestMultipartBody,\n} from './handlers/RequestHandler'\n\nexport type {\n  MockedResponse,\n  ResponseTransformer,\n  ResponseComposition,\n  ResponseCompositionOptions,\n  ResponseFunction,\n} from './response'\n\nexport type {\n  RestRequest,\n  RestContext,\n  RequestQuery,\n  ParsedRestRequest,\n} from './handlers/RestHandler'\n\nexport type {\n  GraphQLContext,\n  GraphQLVariables,\n  GraphQLRequest,\n  GraphQLRequestBody,\n  GraphQLJsonRequestBody,\n} from './handlers/GraphQLHandler'\n\nexport type { Path, PathParams, Match } from './utils/matching/matchRequestUrl'\nexport type { DelayMode } from './context/delay'\nexport { ParsedGraphQLRequest } from './utils/internal/parseGraphQLRequest'\n","export { status } from './status'\nexport { set } from './set'\nexport { cookie } from './cookie'\nexport { body } from './body'\nexport { data } from './data'\nexport { extensions } from './extensions'\nexport { delay } from './delay'\nexport { errors } from './errors'\nexport { fetch } from './fetch'\nexport { json } from './json'\nexport { text } from './text'\nexport { xml } from './xml'\n","import statuses from 'statuses/codes.json'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a response status code and text.\n * @example\n * res(ctx.status(301))\n * res(ctx.status(400, 'Custom status text'))\n * @see {@link https://mswjs.io/docs/api/context/status `ctx.status()`}\n */\nexport const status = (\n  statusCode: number,\n  statusText?: string,\n): ResponseTransformer => {\n  return (res) => {\n    res.status = statusCode\n    res.statusText =\n      statusText || statuses[String(statusCode) as keyof typeof statuses]\n\n    return res\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { ResponseTransformer } from '../response'\n\nexport type HeadersObject<KeyType extends string = string> = Record<\n  KeyType,\n  string | string[]\n>\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\n */\nexport type ForbiddenHeaderNames =\n  | 'cookie'\n  | 'cookie2'\n  | 'set-cookie'\n  | 'set-cookie2'\n\nexport type ForbiddenHeaderError<HeaderName extends string> =\n  `SafeResponseHeader: the '${HeaderName}' header cannot be set on the response. Please use the 'ctx.cookie()' function instead.`\n\n/**\n * Sets one or multiple response headers.\n * @example\n * ctx.set('Content-Type', 'text/plain')\n * ctx.set({\n *   'Accept': 'application/javascript',\n *   'Content-Type': \"text/plain\"\n * })\n * @see {@link https://mswjs.io/docs/api/context/set `ctx.set()`}\n */\nexport function set<N extends string | HeadersObject>(\n  ...args: N extends string\n    ? Lowercase<N> extends ForbiddenHeaderNames\n      ? [ForbiddenHeaderError<N>]\n      : [N, string]\n    : N extends HeadersObject<infer CookieName>\n    ? Lowercase<CookieName> extends ForbiddenHeaderNames\n      ? [ForbiddenHeaderError<CookieName>]\n      : [N]\n    : [N]\n): ResponseTransformer {\n  return (res) => {\n    const [name, value] = args\n\n    if (typeof name === 'string') {\n      res.headers.append(name, value as string)\n    } else {\n      const headers = objectToHeaders(name)\n      headers.forEach((value, name) => {\n        res.headers.append(name, value)\n      })\n    }\n\n    return res\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { ResponseTransformer } from '../response'\n\n/**\n * Sets a given cookie on the mocked response.\n * @example res(ctx.cookie('name', 'value'))\n */\nexport const cookie = (\n  name: string,\n  value: string,\n  options?: cookieUtils.CookieSerializeOptions,\n): ResponseTransformer => {\n  return (res) => {\n    const serializedCookie = cookieUtils.serialize(name, value, options)\n    res.headers.append('Set-Cookie', serializedCookie)\n\n    if (typeof document !== 'undefined') {\n      document.cookie = serializedCookie\n    }\n\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a raw response body. Does not append any `Content-Type` headers.\n * @example\n * res(ctx.body('Successful response'))\n * res(ctx.body(JSON.stringify({ key: 'value' })))\n * @see {@link https://mswjs.io/docs/api/context/body `ctx.body()`}\n */\nexport const body = <\n  BodyType extends string | Blob | BufferSource | ReadableStream | FormData,\n>(\n  value: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.body = value\n    return res\n  }\n}\n","/**\n * Parses a given value into a JSON.\n * Does not throw an exception on an invalid JSON string.\n */\nexport function jsonParse<ValueType extends Record<string, any>>(\n  value: any,\n): ValueType | undefined {\n  try {\n    return JSON.parse(value)\n  } catch (error) {\n    return undefined\n  }\n}\n","/**\n * Determines if the given value is an object.\n */\nexport function isObject(value: any): boolean {\n  return value != null && typeof value === 'object' && !Array.isArray(value)\n}\n","import { isObject } from './isObject'\n\n/**\n * Deeply merges two given objects with the right one\n * having a priority during property assignment.\n */\nexport function mergeRight(\n  left: Record<string, any>,\n  right: Record<string, any>,\n) {\n  return Object.entries(right).reduce((result, [key, rightValue]) => {\n    const leftValue = result[key]\n\n    if (Array.isArray(leftValue) && Array.isArray(rightValue)) {\n      result[key] = leftValue.concat(rightValue)\n      return result\n    }\n\n    if (isObject(leftValue) && isObject(rightValue)) {\n      result[key] = mergeRight(leftValue, rightValue)\n      return result\n    }\n\n    result[key] = rightValue\n    return result\n  }, Object.assign({}, left))\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets the given value as the JSON body of the response.\n * Appends a `Content-Type: application/json` header on the\n * mocked response.\n * @example\n * res(ctx.json('Some string'))\n * res(ctx.json({ key: 'value' }))\n * res(ctx.json([1, '2', false, { ok: true }]))\n * @see {@link https://mswjs.io/docs/api/context/json `ctx.json()`}\n */\nexport const json = <BodyTypeJSON>(\n  body: BodyTypeJSON,\n): ResponseTransformer<BodyTypeJSON> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'application/json')\n    res.body = JSON.stringify(body) as any\n\n    return res\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets a given payload as a GraphQL response body.\n * @example\n * res(ctx.data({ user: { firstName: 'John' }}))\n * @see {@link https://mswjs.io/docs/api/context/data `ctx.data()`}\n */\nexport const data: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { data: payload })\n\n    return json(nextBody)(res)\n  }\n}\n","import { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\nimport { GraphQLPayloadContext } from '../typeUtils'\n\n/**\n * Sets the GraphQL extensions on a given response.\n * @example\n * res(ctx.extensions({ tracing: { version: 1 }}))\n * @see {@link https://mswjs.io/docs/api/context/extensions `ctx.extensions()`}\n */\nexport const extensions: GraphQLPayloadContext<Record<string, unknown>> = (\n  payload,\n) => {\n  return (res) => {\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { extensions: payload })\n    return json(nextBody)(res)\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { ResponseTransformer } from '../response'\n\nexport const SET_TIMEOUT_MAX_ALLOWED_INT = 2147483647\nexport const MIN_SERVER_RESPONSE_TIME = 100\nexport const MAX_SERVER_RESPONSE_TIME = 400\nexport const NODE_SERVER_RESPONSE_TIME = 5\n\nconst getRandomServerResponseTime = () => {\n  if (isNodeProcess()) {\n    return NODE_SERVER_RESPONSE_TIME\n  }\n\n  return Math.floor(\n    Math.random() * (MAX_SERVER_RESPONSE_TIME - MIN_SERVER_RESPONSE_TIME) +\n      MIN_SERVER_RESPONSE_TIME,\n  )\n}\n\nexport type DelayMode = 'real' | 'infinite'\n\n/**\n * Delays the response by the given duration (ms).\n * @example\n * res(ctx.delay(1200)) // delay response by 1200ms\n * res(ctx.delay()) // emulate realistic server response time\n * res(ctx.delay('infinite')) // delay response infinitely\n * @see {@link https://mswjs.io/docs/api/context/delay `ctx.delay()`}\n */\nexport const delay = (\n  durationOrMode?: DelayMode | number,\n): ResponseTransformer => {\n  return (res) => {\n    let delayTime: number\n\n    if (typeof durationOrMode === 'string') {\n      switch (durationOrMode) {\n        case 'infinite': {\n          // Using `Infinity` as a delay value executes the response timeout immediately.\n          // Instead, use the maximum allowed integer for `setTimeout`.\n          delayTime = SET_TIMEOUT_MAX_ALLOWED_INT\n          break\n        }\n        case 'real': {\n          delayTime = getRandomServerResponseTime()\n          break\n        }\n        default: {\n          throw new Error(\n            `Failed to delay a response: unknown delay mode \"${durationOrMode}\". Please make sure you provide one of the supported modes (\"real\", \"infinite\") or a number to \"ctx.delay\".`,\n          )\n        }\n      }\n    } else if (typeof durationOrMode === 'undefined') {\n      // Use random realistic server response time when no explicit delay duration was provided.\n      delayTime = getRandomServerResponseTime()\n    } else {\n      // Guard against passing values like `Infinity` or `Number.MAX_VALUE`\n      // as the response delay duration. They don't produce the result you may expect.\n      if (durationOrMode > SET_TIMEOUT_MAX_ALLOWED_INT) {\n        throw new Error(\n          `Failed to delay a response: provided delay duration (${durationOrMode}) exceeds the maximum allowed duration for \"setTimeout\" (${SET_TIMEOUT_MAX_ALLOWED_INT}). This will cause the response to be returned immediately. Please use a number within the allowed range to delay the response by exact duration, or consider the \"infinite\" delay mode to delay the response indefinitely.`,\n        )\n      }\n\n      delayTime = durationOrMode\n    }\n\n    res.delay = delayTime\n    return res\n  }\n}\n","import type { GraphQLError } from 'graphql'\nimport { ResponseTransformer } from '../response'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\n/**\n * Sets a given list of GraphQL errors on the mocked response.\n * @example res(ctx.errors([{ message: 'Unauthorized' }]))\n * @see {@link https://mswjs.io/docs/api/context/errors}\n */\nexport const errors = <\n  ErrorsType extends readonly Partial<GraphQLError>[] | null | undefined,\n>(\n  errorsList: ErrorsType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    if (errorsList == null) {\n      return res\n    }\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { errors: errorsList })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { Headers } from 'headers-polyfill'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nconst useFetch: (input: RequestInfo, init?: RequestInit) => Promise<Response> =\n  isNodeProcess() ? require('node-fetch') : window.fetch\n\nexport const augmentRequestInit = (requestInit: RequestInit): RequestInit => {\n  const headers = new Headers(requestInit.headers)\n  headers.set('x-msw-bypass', 'true')\n\n  return {\n    ...requestInit,\n    headers: headers.all(),\n  }\n}\n\nconst createFetchRequestParameters = (input: MockedRequest): RequestInit => {\n  const { body, method } = input\n  const requestParameters: RequestInit = {\n    ...input,\n    body: undefined,\n  }\n\n  if (['GET', 'HEAD'].includes(method)) {\n    return requestParameters\n  }\n\n  if (\n    typeof body === 'object' ||\n    typeof body === 'number' ||\n    typeof body === 'boolean'\n  ) {\n    requestParameters.body = JSON.stringify(body)\n  } else {\n    requestParameters.body = body\n  }\n\n  return requestParameters\n}\n\n/**\n * Performs a bypassed request inside a request handler.\n * @example\n * const originalResponse = await ctx.fetch(req)\n * @see {@link https://mswjs.io/docs/api/context/fetch `ctx.fetch()`}\n */\nexport const fetch = (\n  input: string | MockedRequest,\n  requestInit: RequestInit = {},\n): Promise<Response> => {\n  if (typeof input === 'string') {\n    return useFetch(input, augmentRequestInit(requestInit))\n  }\n\n  const requestParameters = createFetchRequestParameters(input)\n  const derivedRequestInit = augmentRequestInit(requestParameters)\n\n  return useFetch(input.url.href, derivedRequestInit)\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets a textual response body. Appends a `Content-Type: text/plain`\n * header on the mocked response.\n * @example res(ctx.text('Successful response'))\n * @see {@link https://mswjs.io/docs/api/context/text `ctx.text()`}\n */\nexport const text = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/plain')\n    res.body = body\n    return res\n  }\n}\n","import { ResponseTransformer } from '../response'\n\n/**\n * Sets an XML response body. Appends a `Content-Type: text/xml` header\n * on the mocked response.\n * @example\n * res(ctx.xml('<node key=\"value\">Content</node>'))\n * @see {@link https://mswjs.io/docs/api/context/xml `ctx.xml()`}\n */\nexport const xml = <BodyType extends string>(\n  body: BodyType,\n): ResponseTransformer<BodyType> => {\n  return (res) => {\n    res.headers.set('Content-Type', 'text/xml')\n    res.body = body\n    return res\n  }\n}\n","import { isNodeProcess } from 'is-node-process'\nimport { StrictEventEmitter } from 'strict-event-emitter'\nimport {\n  SetupWorkerInternalContext,\n  SetupWorkerApi,\n  ServiceWorkerIncomingEventsMap,\n  WorkerLifecycleEventsMap,\n} from './glossary'\nimport { createStartHandler } from './start/createStartHandler'\nimport { createStop } from './stop/createStop'\nimport * as requestHandlerUtils from '../utils/internal/requestHandlerUtils'\nimport { ServiceWorkerMessage } from './start/utils/createMessageChannel'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { RestHandler } from '../handlers/RestHandler'\nimport { prepareStartHandler } from './start/utils/prepareStartHandler'\nimport { createFallbackStart } from './start/createFallbackStart'\nimport { createFallbackStop } from './stop/createFallbackStop'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { pipeEvents } from '../utils/internal/pipeEvents'\nimport { toReadonlyArray } from '../utils/internal/toReadonlyArray'\n\ninterface Listener {\n  target: EventTarget\n  eventType: string\n  callback: EventListener\n}\n\n// Declare the list of event handlers on the module's scope\n// so it persists between Fash refreshes of the application's code.\nlet listeners: Listener[] = []\n\n/**\n * Creates a new mock Service Worker registration\n * with the given request handlers.\n * @param {RequestHandler[]} requestHandlers List of request handlers\n * @see {@link https://mswjs.io/docs/api/setup-worker `setupWorker`}\n */\nexport function setupWorker(\n  ...requestHandlers: RequestHandler[]\n): SetupWorkerApi {\n  requestHandlers.forEach((handler) => {\n    if (Array.isArray(handler))\n      throw new Error(\n        devUtils.formatMessage(\n          'Failed to call \"setupWorker\" given an Array of request handlers (setupWorker([a, b])), expected to receive each handler individually: setupWorker(a, b).',\n        ),\n      )\n  })\n\n  // Error when attempting to run this function in a Node.js environment.\n  if (isNodeProcess()) {\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.',\n      ),\n    )\n  }\n\n  const emitter = new StrictEventEmitter<WorkerLifecycleEventsMap>()\n  const publicEmitter = new StrictEventEmitter<WorkerLifecycleEventsMap>()\n  pipeEvents(emitter, publicEmitter)\n\n  const context: SetupWorkerInternalContext = {\n    // Mocking is not considered enabled until the worker\n    // signals back the successful activation event.\n    isMockingEnabled: false,\n    startOptions: undefined,\n    worker: null,\n    registration: null,\n    requestHandlers: [...requestHandlers],\n    emitter,\n    workerChannel: {\n      on(eventType, callback) {\n        context.events.addListener(\n          navigator.serviceWorker,\n          'message',\n          (event: MessageEvent) => {\n            // Avoid messages broadcasted from unrelated workers.\n            if (event.source !== context.worker) {\n              return\n            }\n\n            const message = event.data as ServiceWorkerMessage<\n              typeof eventType,\n              any\n            >\n\n            if (!message) {\n              return\n            }\n\n            if (message.type === eventType) {\n              callback(event, message)\n            }\n          },\n        )\n      },\n      send(type) {\n        context.worker?.postMessage(type)\n      },\n    },\n    events: {\n      addListener(\n        target: EventTarget,\n        eventType: string,\n        callback: EventListener,\n      ) {\n        target.addEventListener(eventType, callback)\n        listeners.push({ eventType, target, callback })\n\n        return () => {\n          target.removeEventListener(eventType, callback)\n        }\n      },\n      removeAllListeners() {\n        for (const { target, eventType, callback } of listeners) {\n          target.removeEventListener(eventType, callback)\n        }\n        listeners = []\n      },\n      once(eventType) {\n        const bindings: Array<() => void> = []\n\n        return new Promise<\n          ServiceWorkerMessage<\n            typeof eventType,\n            ServiceWorkerIncomingEventsMap[typeof eventType]\n          >\n        >((resolve, reject) => {\n          const handleIncomingMessage = (event: MessageEvent) => {\n            try {\n              const message = event.data\n\n              if (message.type === eventType) {\n                resolve(message)\n              }\n            } catch (error) {\n              reject(error)\n            }\n          }\n\n          bindings.push(\n            context.events.addListener(\n              navigator.serviceWorker,\n              'message',\n              handleIncomingMessage,\n            ),\n            context.events.addListener(\n              navigator.serviceWorker,\n              'messageerror',\n              reject,\n            ),\n          )\n        }).finally(() => {\n          bindings.forEach((unbind) => unbind())\n        })\n      },\n    },\n    useFallbackMode:\n      !('serviceWorker' in navigator) || location.protocol === 'file:',\n  }\n\n  const startHandler = context.useFallbackMode\n    ? createFallbackStart(context)\n    : createStartHandler(context)\n  const stopHandler = context.useFallbackMode\n    ? createFallbackStop(context)\n    : createStop(context)\n\n  return {\n    start: prepareStartHandler(startHandler, context),\n    stop() {\n      context.events.removeAllListeners()\n      context.emitter.removeAllListeners()\n      publicEmitter.removeAllListeners()\n      stopHandler()\n    },\n\n    use(...handlers) {\n      requestHandlerUtils.use(context.requestHandlers, ...handlers)\n    },\n\n    restoreHandlers() {\n      requestHandlerUtils.restoreHandlers(context.requestHandlers)\n    },\n\n    resetHandlers(...nextHandlers) {\n      context.requestHandlers = requestHandlerUtils.resetHandlers(\n        requestHandlers,\n        ...nextHandlers,\n      )\n    },\n\n    listHandlers() {\n      return toReadonlyArray(context.requestHandlers)\n    },\n\n    printHandlers() {\n      const handlers = this.listHandlers()\n\n      handlers.forEach((handler) => {\n        const { header, callFrame } = handler.info\n        const pragma = handler.info.hasOwnProperty('operationType')\n          ? '[graphql]'\n          : '[rest]'\n\n        console.groupCollapsed(`${pragma} ${header}`)\n\n        if (callFrame) {\n          console.log(`Declaration: ${callFrame}`)\n        }\n\n        console.log('Handler:', handler)\n\n        if (handler instanceof RestHandler) {\n          console.log(\n            'Match:',\n            `https://mswjs.io/repl?path=${handler.info.path}`,\n          )\n        }\n\n        console.groupEnd()\n      })\n    },\n\n    events: {\n      on(...args) {\n        return publicEmitter.on(...args)\n      },\n      removeListener(...args) {\n        return publicEmitter.removeListener(...args)\n      },\n      removeAllListeners(...args) {\n        return publicEmitter.removeAllListeners(...args)\n      },\n    },\n  }\n}\n","import { until } from '@open-draft/until'\nimport { getWorkerInstance } from './utils/getWorkerInstance'\nimport { enableMocking } from './utils/enableMocking'\nimport { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { createRequestListener } from './createRequestListener'\nimport { requestIntegrityCheck } from '../../utils/internal/requestIntegrityCheck'\nimport { deferNetworkRequestsUntil } from '../../utils/deferNetworkRequestsUntil'\nimport { createResponseListener } from './createResponseListener'\nimport { validateWorkerScope } from './utils/validateWorkerScope'\nimport { devUtils } from '../../utils/internal/devUtils'\n\nexport const createStartHandler = (\n  context: SetupWorkerInternalContext,\n): StartHandler => {\n  return function start(options, customOptions) {\n    const startWorkerInstance = async () => {\n      // Remove all previously existing event listeners.\n      // This way none of the listeners persists between Fast refresh\n      // of the application's code.\n      context.events.removeAllListeners()\n\n      // Handle requests signaled by the worker.\n      context.workerChannel.on(\n        'REQUEST',\n        createRequestListener(context, options),\n      )\n\n      // Handle responses signaled by the worker.\n      context.workerChannel.on('RESPONSE', createResponseListener(context))\n\n      const instance = await getWorkerInstance(\n        options.serviceWorker.url,\n        options.serviceWorker.options,\n        options.findWorker,\n      )\n\n      const [worker, registration] = instance\n\n      if (!worker) {\n        const missingWorkerMessage = customOptions?.findWorker\n          ? devUtils.formatMessage(\n              `Failed to locate the Service Worker registration using a custom \"findWorker\" predicate.\n\nPlease ensure that the custom predicate properly locates the Service Worker registration at \"%s\".\nMore details: https://mswjs.io/docs/api/setup-worker/start#findworker\n`,\n              options.serviceWorker.url,\n            )\n          : devUtils.formatMessage(\n              `Failed to locate the Service Worker registration.\n\nThis most likely means that the worker script URL \"%s\" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.\n\nPlease consider using a custom \"serviceWorker.url\" option to point to the actual worker script location, or a custom \"findWorker\" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,\n              options.serviceWorker.url,\n              location.host,\n            )\n\n        throw new Error(missingWorkerMessage)\n      }\n\n      context.worker = worker\n      context.registration = registration\n\n      context.events.addListener(window, 'beforeunload', () => {\n        if (worker.state !== 'redundant') {\n          // Notify the Service Worker that this client has closed.\n          // Internally, it's similar to disabling the mocking, only\n          // client close event has a handler that self-terminates\n          // the Service Worker when there are no open clients.\n          context.workerChannel.send('CLIENT_CLOSED')\n        }\n        // Make sure we're always clearing the interval - there are reports that not doing this can\n        // cause memory leaks in headless browser environments.\n        window.clearInterval(context.keepAliveInterval)\n      })\n\n      // Check if the active Service Worker is the latest published one\n      const [integrityError] = await until(() =>\n        requestIntegrityCheck(context, worker),\n      )\n\n      if (integrityError) {\n        devUtils.error(`\\\nDetected outdated Service Worker: ${integrityError.message}\n\nThe mocking is still enabled, but it's highly recommended that you update your Service Worker by running:\n\n$ npx msw init <PUBLIC_DIR>\n\nThis is necessary to ensure that the Service Worker is in sync with the library to guarantee its stability.\nIf this message still persists after updating, please report an issue: https://github.com/open-draft/msw/issues\\\n      `)\n      }\n\n      context.keepAliveInterval = window.setInterval(\n        () => context.workerChannel.send('KEEPALIVE_REQUEST'),\n        5000,\n      )\n\n      // Warn the user when loading the page that lies outside\n      // of the worker's scope.\n      validateWorkerScope(registration, context.startOptions)\n\n      return registration\n    }\n\n    const workerRegistration = startWorkerInstance().then(\n      async (registration) => {\n        const pendingInstance = registration.installing || registration.waiting\n\n        // Wait until the worker is activated.\n        // Assume the worker is already activated if there's no pending registration\n        // (i.e. when reloading the page after a successful activation).\n        if (pendingInstance) {\n          await new Promise<void>((resolve) => {\n            pendingInstance.addEventListener('statechange', () => {\n              if (pendingInstance.state === 'activated') {\n                return resolve()\n              }\n            })\n          })\n        }\n\n        // Print the activation message only after the worker has been activated.\n        await enableMocking(context, options).catch((error) => {\n          throw new Error(`Failed to enable mocking: ${error?.message}`)\n        })\n\n        return registration\n      },\n    )\n\n    // Defer any network requests until the Service Worker instance is ready.\n    // This prevents a race condition between the Service Worker registration\n    // and application's runtime requests (i.e. requests on mount).\n    if (options.waitUntilReady) {\n      deferNetworkRequestsUntil(workerRegistration)\n    }\n\n    return workerRegistration\n  }\n}\n","import { until } from '@open-draft/until'\nimport { getWorkerByRegistration } from './getWorkerByRegistration'\nimport { ServiceWorkerInstanceTuple, FindWorker } from '../../glossary'\nimport { getAbsoluteWorkerUrl } from '../../../utils/url/getAbsoluteWorkerUrl'\nimport { devUtils } from '../../../utils/internal/devUtils'\n\n/**\n * Returns an active Service Worker instance.\n * When not found, registers a new Service Worker.\n */\nexport const getWorkerInstance = async (\n  url: string,\n  options: RegistrationOptions = {},\n  findWorker: FindWorker,\n): Promise<ServiceWorkerInstanceTuple> => {\n  // Resolve the absolute Service Worker URL.\n  const absoluteWorkerUrl = getAbsoluteWorkerUrl(url)\n\n  const mockRegistrations = await navigator.serviceWorker\n    .getRegistrations()\n    .then((registrations) =>\n      registrations.filter((registration) =>\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n      ),\n    )\n  if (!navigator.serviceWorker.controller && mockRegistrations.length > 0) {\n    // Reload the page when it has associated workers, but no active controller.\n    // The absence of a controller can mean either:\n    // - page has no Service Worker associated with it\n    // - page has been hard-reloaded and its workers won't be used until the next reload.\n    // Since we've checked that there are registrations associated with this page,\n    // at this point we are sure it's hard reload that falls into this clause.\n    location.reload()\n  }\n\n  const [existingRegistration] = mockRegistrations\n\n  if (existingRegistration) {\n    // When the Service Worker is registered, update it and return the reference.\n    return existingRegistration.update().then(() => {\n      return [\n        getWorkerByRegistration(\n          existingRegistration,\n          absoluteWorkerUrl,\n          findWorker,\n        ),\n        existingRegistration,\n      ]\n    })\n  }\n\n  // When the Service Worker wasn't found, register it anew and return the reference.\n  const [error, instance] = await until<ServiceWorkerInstanceTuple>(\n    async () => {\n      const registration = await navigator.serviceWorker.register(url, options)\n      return [\n        // Compare existing worker registration by its worker URL,\n        // to prevent irrelevant workers to resolve here (such as Codesandbox worker).\n        getWorkerByRegistration(registration, absoluteWorkerUrl, findWorker),\n        registration,\n      ]\n    },\n  )\n\n  // Handle Service Worker registration errors.\n  if (error) {\n    const isWorkerMissing = error.message.includes('(404)')\n\n    // Produce a custom error message when given a non-existing Service Worker url.\n    // Suggest developers to check their setup.\n    if (isWorkerMissing) {\n      const scopeUrl = new URL(options?.scope || '/', location.href)\n\n      throw new Error(\n        devUtils.formatMessage(`\\\nFailed to register a Service Worker for scope ('${scopeUrl.href}') with script ('${absoluteWorkerUrl}'): Service Worker script does not exist at the given path.\n\nDid you forget to run \"npx msw init <PUBLIC_DIR>\"?\n\nLearn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`),\n      )\n    }\n\n    // Fallback error message for any other registration errors.\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to register the Service Worker:\\n\\n%s',\n        error.message,\n      ),\n    )\n  }\n\n  return instance\n}\n","import { FindWorker } from '../../glossary'\n\n/**\n * Attempts to resolve a Service Worker instance from a given registration,\n * regardless of its state (active, installing, waiting).\n */\nexport const getWorkerByRegistration = (\n  registration: ServiceWorkerRegistration,\n  absoluteWorkerUrl: string,\n  findWorker: FindWorker,\n): ServiceWorker | null => {\n  const allStates = [\n    registration.active,\n    registration.installing,\n    registration.waiting,\n  ]\n  const existingStates = allStates.filter(Boolean) as ServiceWorker[]\n  const mockWorker = existingStates.find((worker) => {\n    return findWorker(worker.scriptURL, absoluteWorkerUrl)\n  })\n\n  return mockWorker || null\n}\n","/**\n * Returns an absolute Service Worker URL based on the given\n * relative URL (known during the registration).\n */\nexport function getAbsoluteWorkerUrl(relativeUrl: string): string {\n  return new URL(relativeUrl, location.origin).href\n}\n","import { format } from 'outvariant'\n\nconst LIBRARY_PREFIX = '[MSW]'\n\n/**\n * Formats a given message by appending the library's prefix string.\n */\nfunction formatMessage(message: string, ...positionals: any[]): string {\n  const interpolatedMessage = format(message, ...positionals)\n  return `${LIBRARY_PREFIX} ${interpolatedMessage}`\n}\n\n/**\n * Prints a library-specific warning.\n */\nfunction warn(message: string, ...positionals: any[]): void {\n  console.warn(formatMessage(message, ...positionals))\n}\n\n/**\n * Prints a library-specific error.\n */\nfunction error(message: string, ...positionals: any[]): void {\n  console.error(formatMessage(message, ...positionals))\n}\n\nexport const devUtils = {\n  formatMessage,\n  warn,\n  error,\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\n\nexport interface PrintStartMessageArgs {\n  quiet?: boolean\n  message?: string\n  workerUrl?: string\n  workerScope?: string\n}\n\n/**\n * Prints a worker activation message in the browser's console.\n */\nexport function printStartMessage(args: PrintStartMessageArgs = {}) {\n  if (args.quiet) {\n    return\n  }\n\n  const message = args.message || 'Mocking enabled.'\n\n  console.groupCollapsed(\n    `%c${devUtils.formatMessage(message)}`,\n    'color:orangered;font-weight:bold;',\n  )\n  console.log(\n    '%cDocumentation: %chttps://mswjs.io/docs',\n    'font-weight:bold',\n    'font-weight:normal',\n  )\n  console.log('Found an issue? https://github.com/mswjs/msw/issues')\n\n  if (args.workerUrl) {\n    console.log('Worker script URL:', args.workerUrl)\n  }\n\n  if (args.workerScope) {\n    console.log('Worker scope:', args.workerScope)\n  }\n\n  console.groupEnd()\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\nimport { StartOptions, SetupWorkerInternalContext } from '../../glossary'\nimport { printStartMessage } from './printStartMessage'\n\n/**\n * Signals the worker to enable the interception of requests.\n */\nexport async function enableMocking(\n  context: SetupWorkerInternalContext,\n  options: StartOptions,\n) {\n  context.workerChannel.send('MOCK_ACTIVATE')\n  await context.events.once('MOCKING_ENABLED')\n\n  // Warn the developer on multiple \"worker.start()\" calls.\n  // While this will not affect the worker in any way,\n  // it likely indicates an issue with the developer's code.\n  if (context.isMockingEnabled) {\n    devUtils.warn(\n      `Found a redundant \"worker.start()\" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this \"worker.start()\" call.`,\n    )\n    return\n  }\n\n  context.isMockingEnabled = true\n\n  printStartMessage({\n    quiet: options.quiet,\n    workerScope: context.registration?.scope,\n    workerUrl: context.worker?.scriptURL,\n  })\n}\n","import {\n  SerializedResponse,\n  ServiceWorkerIncomingEventsMap,\n} from '../../glossary'\n\nexport interface ServiceWorkerMessage<\n  EventType extends keyof ServiceWorkerIncomingEventsMap,\n  EventPayload,\n> {\n  type: EventType\n  payload: EventPayload\n}\n\ninterface WorkerChannelEventsMap {\n  MOCK_RESPONSE: [data: SerializedResponse<any>, body?: [ArrayBuffer]]\n  NOT_FOUND: []\n  NETWORK_ERROR: [data: { name: string; message: string }]\n}\n\nexport class WorkerChannel {\n  constructor(private readonly port: MessagePort) {}\n\n  public postMessage<Event extends keyof WorkerChannelEventsMap>(\n    event: Event,\n    ...rest: WorkerChannelEventsMap[Event]\n  ): void {\n    const [data, transfer] = rest\n    this.port.postMessage({ type: event, data }, { transfer })\n  }\n}\n","export class NetworkError extends Error {\n  constructor(message: string) {\n    super(message)\n    this.name = 'NetworkError'\n  }\n}\n","import { encodeBuffer } from '@mswjs/interceptors'\nimport { Headers } from 'headers-polyfill'\nimport { ServiceWorkerIncomingRequest } from '../../setupWorker/glossary'\nimport { MockedRequest } from './MockedRequest'\n\n/**\n * Converts a given request received from the Service Worker\n * into a `MockedRequest` instance.\n */\nexport function parseWorkerRequest(\n  rawRequest: ServiceWorkerIncomingRequest,\n): MockedRequest {\n  const url = new URL(rawRequest.url)\n  const headers = new Headers(rawRequest.headers)\n\n  return new MockedRequest(url, {\n    ...rawRequest,\n    body: encodeBuffer(rawRequest.body || ''),\n    headers,\n  })\n}\n","import * as cookieUtils from 'cookie'\nimport { store } from '@mswjs/cookies'\nimport { IsomorphicRequest, RequestInit } from '@mswjs/interceptors'\nimport { decodeBuffer } from '@mswjs/interceptors/lib/utils/bufferUtils'\nimport { Headers } from 'headers-polyfill'\nimport { DefaultBodyType } from '../../handlers/RequestHandler'\nimport { MockedResponse } from '../../response'\nimport { getRequestCookies } from './getRequestCookies'\nimport { parseBody } from './parseBody'\nimport { isStringEqual } from '../internal/isStringEqual'\n\nexport type RequestCache =\n  | 'default'\n  | 'no-store'\n  | 'reload'\n  | 'no-cache'\n  | 'force-cache'\n  | 'only-if-cached'\n\nexport type RequestMode = 'navigate' | 'same-origin' | 'no-cors' | 'cors'\n\nexport type RequestRedirect = 'follow' | 'error' | 'manual'\n\nexport type RequestDestination =\n  | ''\n  | 'audio'\n  | 'audioworklet'\n  | 'document'\n  | 'embed'\n  | 'font'\n  | 'frame'\n  | 'iframe'\n  | 'image'\n  | 'manifest'\n  | 'object'\n  | 'paintworklet'\n  | 'report'\n  | 'script'\n  | 'sharedworker'\n  | 'style'\n  | 'track'\n  | 'video'\n  | 'xslt'\n  | 'worker'\n\nexport type RequestPriority = 'high' | 'low' | 'auto'\n\nexport type RequestReferrerPolicy =\n  | ''\n  | 'no-referrer'\n  | 'no-referrer-when-downgrade'\n  | 'origin'\n  | 'origin-when-cross-origin'\n  | 'same-origin'\n  | 'strict-origin'\n  | 'strict-origin-when-cross-origin'\n  | 'unsafe-url'\n\nexport interface MockedRequestInit extends RequestInit {\n  id?: string\n  cache?: RequestCache\n  redirect?: RequestRedirect\n  integrity?: string\n  keepalive?: boolean\n  mode?: RequestMode\n  priority?: RequestPriority\n  destination?: RequestDestination\n  referrer?: string\n  referrerPolicy?: RequestReferrerPolicy\n  cookies?: Record<string, string>\n}\n\nexport class MockedRequest<\n  RequestBody extends DefaultBodyType = DefaultBodyType,\n> extends IsomorphicRequest {\n  public readonly cache: RequestCache\n  public readonly cookies: Record<string, string>\n  public readonly destination: RequestDestination\n  public readonly integrity: string\n  public readonly keepalive: boolean\n  public readonly mode: RequestMode\n  public readonly priority: RequestPriority\n  public readonly redirect: RequestRedirect\n  public readonly referrer: string\n  public readonly referrerPolicy: RequestReferrerPolicy\n\n  constructor(url: URL, init: MockedRequestInit = {}) {\n    super(url, init)\n    if (init.id) {\n      this.id = init.id\n    }\n    this.cache = init.cache || 'default'\n    this.destination = init.destination || ''\n    this.integrity = init.integrity || ''\n    this.keepalive = init.keepalive || false\n    this.mode = init.mode || 'cors'\n    this.priority = init.priority || 'auto'\n    this.redirect = init.redirect || 'follow'\n    this.referrer = init.referrer || ''\n    this.referrerPolicy = init.referrerPolicy || 'no-referrer'\n    this.cookies = init.cookies || this.getCookies()\n  }\n\n  /**\n   * Get parsed request body. The type is inferred from the content type.\n   *\n   * @deprecated - Use `req.text()`, `req.json()` or `req.arrayBuffer()`\n   * to read the request body as a plain text, JSON, or ArrayBuffer.\n   */\n  public get body(): RequestBody {\n    const text = decodeBuffer(this['_body'])\n\n    /**\n     * @deprecated https://github.com/mswjs/msw/issues/1318\n     * @fixme Remove this assumption and let the users read\n     * request body explicitly using \".json()\"/\".text()\"/\".arrayBuffer()\".\n     */\n    // Parse the request's body based on the \"Content-Type\" header.\n    const body = parseBody(text, this.headers)\n\n    if (isStringEqual(this.method, 'GET') && body === '') {\n      return undefined as RequestBody\n    }\n\n    return body as RequestBody\n  }\n\n  /**\n   * Bypass the intercepted request.\n   * This will make a call to the actual endpoint requested.\n   */\n  public passthrough(): MockedResponse<null> {\n    return {\n      // Constructing a dummy \"101 Continue\" mocked response\n      // to keep the return type of the resolver consistent.\n      status: 101,\n      statusText: 'Continue',\n      headers: new Headers(),\n      body: null,\n      // Setting \"passthrough\" to true will signal the response pipeline\n      // to perform this intercepted request as-is.\n      passthrough: true,\n      once: false,\n    }\n  }\n\n  private getCookies(): Record<string, string> {\n    // Parse the cookies passed in the original request \"cookie\" header.\n    const requestCookiesString = this.headers.get('cookie')\n    const ownCookies = requestCookiesString\n      ? cookieUtils.parse(requestCookiesString)\n      : {}\n\n    store.hydrate()\n\n    const cookiesFromStore = Array.from(\n      store.get({ ...this, url: this.url.href })?.entries(),\n    ).reduce((cookies, [name, { value }]) => {\n      return Object.assign(cookies, { [name.trim()]: value })\n    }, {})\n\n    // Get existing document cookies that are applicable\n    // to this request based on its \"credentials\" policy.\n    const cookiesFromDocument = getRequestCookies(this)\n\n    const forwardedCookies = {\n      ...cookiesFromDocument,\n      ...cookiesFromStore,\n    }\n\n    for (const [name, value] of Object.entries(forwardedCookies)) {\n      this.headers.append('cookie', `${name}=${value}`)\n    }\n\n    return {\n      ...forwardedCookies,\n      ...ownCookies,\n    }\n  }\n}\n","import * as cookieUtils from 'cookie'\nimport { MockedRequest } from './MockedRequest'\n\nfunction getAllCookies() {\n  return cookieUtils.parse(document.cookie)\n}\n\n/**\n * Returns relevant document cookies based on the request `credentials` option.\n */\nexport function getRequestCookies(request: MockedRequest) {\n  /**\n   * @note No cookies persist on the document in Node.js: no document.\n   */\n  if (typeof document === 'undefined' || typeof location === 'undefined') {\n    return {}\n  }\n\n  switch (request.credentials) {\n    case 'same-origin': {\n      // Return document cookies only when requested a resource\n      // from the same origin as the current document.\n      return location.origin === request.url.origin ? getAllCookies() : {}\n    }\n\n    case 'include': {\n      // Return all document cookies.\n      return getAllCookies()\n    }\n\n    default: {\n      return {}\n    }\n  }\n}\n","import { stringToHeaders } from 'headers-polyfill'\nimport { DefaultRequestMultipartBody } from '../../handlers/RequestHandler'\n\ninterface ParsedContentHeaders {\n  name: string\n  filename?: string\n  contentType: string\n}\n\ninterface ContentDispositionDirective {\n  [key: string]: string | undefined\n  name: string\n  filename?: string\n  'form-data': string\n}\n\nfunction parseContentHeaders(headersString: string): ParsedContentHeaders {\n  const headers = stringToHeaders(headersString)\n  const contentType = headers.get('content-type') || 'text/plain'\n  const disposition = headers.get('content-disposition')\n\n  if (!disposition) {\n    throw new Error('\"Content-Disposition\" header is required.')\n  }\n\n  const directives = disposition.split(';').reduce((acc, chunk) => {\n    const [name, ...rest] = chunk.trim().split('=')\n    acc[name] = rest.join('=')\n    return acc\n  }, {} as ContentDispositionDirective)\n\n  const name = directives.name?.slice(1, -1)\n  const filename = directives.filename?.slice(1, -1)\n\n  return {\n    name,\n    filename,\n    contentType,\n  }\n}\n\n/**\n * Parses a given string as a multipart/form-data.\n * Does not throw an exception on an invalid multipart string.\n */\nexport function parseMultipartData<T extends DefaultRequestMultipartBody>(\n  data: string,\n  headers?: Headers,\n): T | undefined {\n  const contentType = headers?.get('content-type')\n\n  if (!contentType) {\n    return undefined\n  }\n\n  const [, ...directives] = contentType.split(/; */)\n  const boundary = directives\n    .filter((d) => d.startsWith('boundary='))\n    .map((s) => s.replace(/^boundary=/, ''))[0]\n\n  if (!boundary) {\n    return undefined\n  }\n\n  const boundaryRegExp = new RegExp(`--+${boundary}`)\n  const fields = data\n    .split(boundaryRegExp)\n    .filter((chunk) => chunk.startsWith('\\r\\n') && chunk.endsWith('\\r\\n'))\n    .map((chunk) => chunk.trimStart().replace(/\\r\\n$/, ''))\n\n  if (!fields.length) {\n    return undefined\n  }\n\n  const parsedBody: DefaultRequestMultipartBody = {}\n\n  try {\n    for (const field of fields) {\n      const [contentHeaders, ...rest] = field.split('\\r\\n\\r\\n')\n      const contentBody = rest.join('\\r\\n\\r\\n')\n      const { contentType, filename, name } =\n        parseContentHeaders(contentHeaders)\n\n      const value =\n        filename === undefined\n          ? contentBody\n          : new File([contentBody], filename, { type: contentType })\n\n      const parsedValue = parsedBody[name]\n\n      if (parsedValue === undefined) {\n        parsedBody[name] = value\n      } else if (Array.isArray(parsedValue)) {\n        parsedBody[name] = [...parsedValue, value]\n      } else {\n        parsedBody[name] = [parsedValue, value]\n      }\n    }\n\n    return parsedBody as T\n  } catch (error) {\n    return undefined\n  }\n}\n","import { jsonParse } from '../internal/jsonParse'\nimport { parseMultipartData } from '../internal/parseMultipartData'\nimport { MockedRequest } from './MockedRequest'\n\n/**\n * Parses a given request/response body based on the \"Content-Type\" header.\n */\nexport function parseBody(body?: MockedRequest['body'], headers?: Headers) {\n  // Return whatever falsey body value is given.\n  if (!body) {\n    return body\n  }\n\n  const contentType = headers?.get('content-type')?.toLowerCase() || ''\n\n  // If the body has a Multipart Content-Type\n  // parse it into an object.\n  const hasMultipartContent = contentType.startsWith('multipart/form-data')\n  if (hasMultipartContent && typeof body !== 'object') {\n    return parseMultipartData(body.toString(), headers) || body\n  }\n\n  // If the intercepted request's body has a JSON Content-Type\n  // parse it into an object.\n  const hasJsonContent = contentType.includes('json')\n\n  if (hasJsonContent && typeof body !== 'object') {\n    return jsonParse(body.toString()) || body\n  }\n\n  // Otherwise leave as-is.\n  return body\n}\n","/**\n * Performs a case-insensitive comparison of two given strings.\n */\nexport function isStringEqual(actual: string, expected: string): boolean {\n  return actual.toLowerCase() === expected.toLowerCase()\n}\n","import { until } from '@open-draft/until'\nimport { StrictEventEmitter } from 'strict-event-emitter'\nimport { RequestHandler } from '../handlers/RequestHandler'\nimport { ServerLifecycleEventsMap } from '../node/glossary'\nimport { MockedResponse } from '../response'\nimport { SharedOptions } from '../sharedOptions'\nimport { RequiredDeep } from '../typeUtils'\nimport { ResponseLookupResult, getResponse } from './getResponse'\nimport { devUtils } from './internal/devUtils'\nimport { MockedRequest } from './request/MockedRequest'\nimport { onUnhandledRequest } from './request/onUnhandledRequest'\nimport { readResponseCookies } from './request/readResponseCookies'\n\nexport interface HandleRequestOptions<ResponseType> {\n  /**\n   * Options for the response resolution process.\n   */\n  resolutionContext?: {\n    baseUrl?: string\n  }\n\n  /**\n   * Transforms a `MockedResponse` instance returned from a handler\n   * to a response instance supported by the lower tooling (i.e. interceptors).\n   */\n  transformResponse?(response: MockedResponse<string>): ResponseType\n\n  /**\n   * Invoked whenever a request is performed as-is.\n   */\n  onPassthroughResponse?(request: MockedRequest): void\n\n  /**\n   * Invoked when the mocked response is ready to be sent.\n   */\n  onMockedResponse?(\n    response: ResponseType,\n    handler: RequiredDeep<ResponseLookupResult>,\n  ): void\n}\n\nexport async function handleRequest<\n  ResponseType extends Record<string, any> = MockedResponse<string>,\n>(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  options: RequiredDeep<SharedOptions>,\n  emitter: StrictEventEmitter<ServerLifecycleEventsMap>,\n  handleRequestOptions?: HandleRequestOptions<ResponseType>,\n): Promise<ResponseType | undefined> {\n  emitter.emit('request:start', request)\n\n  // Perform bypassed requests (i.e. issued via \"ctx.fetch\") as-is.\n  if (request.headers.get('x-msw-bypass') === 'true') {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Resolve a mocked response from the list of request handlers.\n  const [lookupError, lookupResult] = await until(() => {\n    return getResponse(\n      request,\n      handlers,\n      handleRequestOptions?.resolutionContext,\n    )\n  })\n\n  if (lookupError) {\n    // Allow developers to react to unhandled exceptions in request handlers.\n    emitter.emit('unhandledException', lookupError, request)\n    throw lookupError\n  }\n\n  const { handler, response } = lookupResult\n\n  // When there's no handler for the request, consider it unhandled.\n  // Allow the developer to react to such cases.\n  if (!handler) {\n    onUnhandledRequest(request, handlers, options.onUnhandledRequest)\n    emitter.emit('request:unhandled', request)\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the handled request returned no mocked response, warn the developer,\n  // as it may be an oversight on their part. Perform the request as-is.\n  if (!response) {\n    devUtils.warn(\n      `\\\nExpected response resolver to return a mocked response Object, but got %s. The original response is going to be used instead.\\\n\\n\n  \\u2022 %s\n    %s\\\n`,\n      response,\n      handler.info.header,\n      handler.info.callFrame,\n    )\n\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // When the developer explicitly returned \"req.passthrough()\" do not warn them.\n  // Perform the request as-is.\n  if (response.passthrough) {\n    emitter.emit('request:end', request)\n    handleRequestOptions?.onPassthroughResponse?.(request)\n    return\n  }\n\n  // Store all the received response cookies in the virtual cookie store.\n  readResponseCookies(request, response)\n\n  emitter.emit('request:match', request)\n\n  const requiredLookupResult =\n    lookupResult as RequiredDeep<ResponseLookupResult>\n\n  const transformedResponse =\n    handleRequestOptions?.transformResponse?.(response) ||\n    (response as any as ResponseType)\n\n  handleRequestOptions?.onMockedResponse?.(\n    transformedResponse,\n    requiredLookupResult,\n  )\n\n  emitter.emit('request:end', request)\n\n  return transformedResponse\n}\n","import { MockedResponse } from '../response'\nimport {\n  RequestHandler,\n  RequestHandlerExecutionResult,\n} from '../handlers/RequestHandler'\nimport { MockedRequest } from './request/MockedRequest'\n\nexport interface ResponseLookupResult {\n  handler?: RequestHandler\n  publicRequest?: any\n  parsedRequest?: any\n  response?: MockedResponse\n}\n\nexport interface ResponseResolutionContext {\n  baseUrl?: string\n}\n\n/**\n * Returns a mocked response for a given request using following request handlers.\n */\nexport const getResponse = async <\n  Request extends MockedRequest,\n  Handler extends RequestHandler[],\n>(\n  request: Request,\n  handlers: Handler,\n  resolutionContext?: ResponseResolutionContext,\n): Promise<ResponseLookupResult> => {\n  const relevantHandlers = handlers.filter((handler) => {\n    return handler.test(request, resolutionContext)\n  })\n\n  if (relevantHandlers.length === 0) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  const result = await relevantHandlers.reduce<\n    Promise<RequestHandlerExecutionResult<any> | null>\n  >(async (executionResult, handler) => {\n    const previousResults = await executionResult\n\n    if (!!previousResults?.response) {\n      return executionResult\n    }\n\n    const result = await handler.run(request, resolutionContext)\n\n    if (result === null || result.handler.shouldSkip) {\n      return null\n    }\n\n    if (!result.response) {\n      return {\n        request: result.request,\n        handler: result.handler,\n        response: undefined,\n        parsedResult: result.parsedResult,\n      }\n    }\n\n    if (result.response.once) {\n      handler.markAsSkipped(true)\n    }\n\n    return result\n  }, Promise.resolve(null))\n\n  // Although reducing a list of relevant request handlers, it's possible\n  // that in the end there will be no handler associted with the request\n  // (i.e. if relevant handlers are fall-through).\n  if (!result) {\n    return {\n      handler: undefined,\n      response: undefined,\n    }\n  }\n\n  return {\n    handler: result.handler,\n    publicRequest: result.request,\n    parsedRequest: result.parsedResult,\n    response: result.response,\n  }\n}\n","import getStringMatchScore from 'js-levenshtein'\nimport {\n  ParsedGraphQLQuery,\n  parseGraphQLRequest,\n} from '../internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from './getPublicUrlFromRequest'\nimport { isStringEqual } from '../internal/isStringEqual'\nimport { RestHandler } from '../../handlers/RestHandler'\nimport { GraphQLHandler } from '../../handlers/GraphQLHandler'\nimport { RequestHandler } from '../../handlers/RequestHandler'\nimport { tryCatch } from '../internal/tryCatch'\nimport { devUtils } from '../internal/devUtils'\nimport { MockedRequest } from './MockedRequest'\n\nconst MAX_MATCH_SCORE = 3\nconst MAX_SUGGESTION_COUNT = 4\nconst TYPE_MATCH_DELTA = 0.5\n\nexport interface UnhandledRequestPrint {\n  warning(): void\n  error(): void\n}\n\nexport type UnhandledRequestCallback = (\n  request: MockedRequest,\n  print: UnhandledRequestPrint,\n) => void\n\nexport type UnhandledRequestStrategy =\n  | 'bypass'\n  | 'warn'\n  | 'error'\n  | UnhandledRequestCallback\n\ninterface RequestHandlerGroups {\n  rest: RestHandler[]\n  graphql: GraphQLHandler[]\n}\n\nfunction groupHandlersByType(handlers: RequestHandler[]): RequestHandlerGroups {\n  return handlers.reduce<RequestHandlerGroups>(\n    (groups, handler) => {\n      if (handler instanceof RestHandler) {\n        groups.rest.push(handler)\n      }\n\n      if (handler instanceof GraphQLHandler) {\n        groups.graphql.push(handler)\n      }\n\n      return groups\n    },\n    {\n      rest: [],\n      graphql: [],\n    },\n  )\n}\n\ntype RequestHandlerSuggestion = [number, RequestHandler]\n\ntype ScoreGetterFn<RequestHandlerType extends RequestHandler> = (\n  request: MockedRequest,\n  handler: RequestHandlerType,\n) => number\n\nfunction getRestHandlerScore(): ScoreGetterFn<RestHandler> {\n  return (request, handler) => {\n    const { path, method } = handler.info\n\n    if (path instanceof RegExp || method instanceof RegExp) {\n      return Infinity\n    }\n\n    const hasSameMethod = isStringEqual(request.method, method)\n\n    // Always treat a handler with the same method as a more similar one.\n    const methodScoreDelta = hasSameMethod ? TYPE_MATCH_DELTA : 0\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n    const score = getStringMatchScore(requestPublicUrl, path)\n\n    return score - methodScoreDelta\n  }\n}\n\nfunction getGraphQLHandlerScore(\n  parsedQuery: ParsedGraphQLQuery,\n): ScoreGetterFn<GraphQLHandler> {\n  return (_, handler) => {\n    if (typeof parsedQuery.operationName === 'undefined') {\n      return Infinity\n    }\n\n    const { operationType, operationName } = handler.info\n\n    if (typeof operationName !== 'string') {\n      return Infinity\n    }\n\n    const hasSameOperationType = parsedQuery.operationType === operationType\n    // Always treat a handler with the same operation type as a more similar one.\n    const operationTypeScoreDelta = hasSameOperationType ? TYPE_MATCH_DELTA : 0\n    const score = getStringMatchScore(parsedQuery.operationName, operationName)\n\n    return score - operationTypeScoreDelta\n  }\n}\n\nfunction getSuggestedHandler(\n  request: MockedRequest,\n  handlers: RestHandler[] | GraphQLHandler[],\n  getScore: ScoreGetterFn<RestHandler> | ScoreGetterFn<GraphQLHandler>,\n): RequestHandler[] {\n  const suggestedHandlers = (handlers as RequestHandler[])\n    .reduce<RequestHandlerSuggestion[]>((suggestions, handler) => {\n      const score = getScore(request, handler as any)\n      return suggestions.concat([[score, handler]])\n    }, [])\n    .sort(([leftScore], [rightScore]) => leftScore - rightScore)\n    .filter(([score]) => score <= MAX_MATCH_SCORE)\n    .slice(0, MAX_SUGGESTION_COUNT)\n    .map(([, handler]) => handler)\n\n  return suggestedHandlers\n}\n\nfunction getSuggestedHandlersMessage(handlers: RequestHandler[]) {\n  if (handlers.length > 1) {\n    return `\\\nDid you mean to request one of the following resources instead?\n\n${handlers.map((handler) => `   ${handler.info.header}`).join('\\n')}`\n  }\n\n  return `Did you mean to request \"${handlers[0].info.header}\" instead?`\n}\n\nexport function onUnhandledRequest(\n  request: MockedRequest,\n  handlers: RequestHandler[],\n  strategy: UnhandledRequestStrategy = 'warn',\n): void {\n  const parsedGraphQLQuery = tryCatch(() => parseGraphQLRequest(request))\n\n  function generateHandlerSuggestion(): string {\n    /**\n     * @note Ignore exceptions during GraphQL request parsing because at this point\n     * we cannot assume the unhandled request is a valid GraphQL request.\n     * If the GraphQL parsing fails, just don't treat it as a GraphQL request.\n     */\n    const handlerGroups = groupHandlersByType(handlers)\n    const relevantHandlers = parsedGraphQLQuery\n      ? handlerGroups.graphql\n      : handlerGroups.rest\n\n    const suggestedHandlers = getSuggestedHandler(\n      request,\n      relevantHandlers,\n      parsedGraphQLQuery\n        ? getGraphQLHandlerScore(parsedGraphQLQuery)\n        : getRestHandlerScore(),\n    )\n\n    return suggestedHandlers.length > 0\n      ? getSuggestedHandlersMessage(suggestedHandlers)\n      : ''\n  }\n\n  function generateUnhandledRequestMessage(): string {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const requestHeader = parsedGraphQLQuery\n      ? `${parsedGraphQLQuery.operationType} ${parsedGraphQLQuery.operationName} (${request.method} ${publicUrl})`\n      : `${request.method} ${publicUrl}`\n    const handlerSuggestion = generateHandlerSuggestion()\n\n    const messageTemplate = [\n      `captured a request without a matching request handler:`,\n      `  \\u2022 ${requestHeader}`,\n      handlerSuggestion,\n      `\\\nIf you still wish to intercept this unhandled request, please create a request handler for it.\nRead more: https://mswjs.io/docs/getting-started/mocks\\\n`,\n    ].filter(Boolean)\n    return messageTemplate.join('\\n\\n')\n  }\n\n  function applyStrategy(strategy: UnhandledRequestStrategy) {\n    // Generate handler suggestions only when applying the strategy.\n    // This saves bandwidth for scenarios when developers opt-out\n    // from the default unhandled request handling strategy.\n    const message = generateUnhandledRequestMessage()\n\n    switch (strategy) {\n      case 'error': {\n        // Print a developer-friendly error.\n        devUtils.error('Error: %s', message)\n\n        // Throw an exception to halt request processing and not perform the original request.\n        throw new Error(\n          devUtils.formatMessage(\n            'Cannot bypass a request when using the \"error\" strategy for the \"onUnhandledRequest\" option.',\n          ),\n        )\n      }\n\n      case 'warn': {\n        devUtils.warn('Warning: %s', message)\n        break\n      }\n\n      case 'bypass':\n        break\n\n      default:\n        throw new Error(\n          devUtils.formatMessage(\n            'Failed to react to an unhandled request: unknown strategy \"%s\". Please provide one of the supported strategies (\"bypass\", \"warn\", \"error\") or a custom callback function as the value of the \"onUnhandledRequest\" option.',\n            strategy,\n          ),\n        )\n    }\n  }\n\n  if (typeof strategy === 'function') {\n    strategy(request, {\n      warning: applyStrategy.bind(null, 'warn'),\n      error: applyStrategy.bind(null, 'error'),\n    })\n    return\n  }\n\n  applyStrategy(strategy)\n}\n","import type {\n  DocumentNode,\n  OperationDefinitionNode,\n  OperationTypeNode,\n} from 'graphql'\nimport { parse } from 'graphql'\nimport { GraphQLVariables } from '../../handlers/GraphQLHandler'\nimport { getPublicUrlFromRequest } from '../request/getPublicUrlFromRequest'\nimport { MockedRequest } from '../request/MockedRequest'\nimport { devUtils } from './devUtils'\nimport { jsonParse } from './jsonParse'\n\ninterface GraphQLInput {\n  query: string | null\n  variables?: GraphQLVariables\n}\n\nexport interface ParsedGraphQLQuery {\n  operationType: OperationTypeNode\n  operationName?: string\n}\n\nexport type ParsedGraphQLRequest<\n  VariablesType extends GraphQLVariables = GraphQLVariables,\n> =\n  | (ParsedGraphQLQuery & {\n      variables?: VariablesType\n    })\n  | undefined\n\nexport function parseDocumentNode(node: DocumentNode): ParsedGraphQLQuery {\n  const operationDef = node.definitions.find((def) => {\n    return def.kind === 'OperationDefinition'\n  }) as OperationDefinitionNode\n\n  return {\n    operationType: operationDef?.operation,\n    operationName: operationDef?.name?.value,\n  }\n}\n\nfunction parseQuery(query: string): ParsedGraphQLQuery | Error {\n  try {\n    const ast = parse(query)\n    return parseDocumentNode(ast)\n  } catch (error) {\n    return error as Error\n  }\n}\n\nexport type GraphQLParsedOperationsMap = Record<string, string[]>\nexport type GraphQLMultipartRequestBody = {\n  operations: string\n  map?: string\n} & {\n  [fileName: string]: File\n}\n\nfunction extractMultipartVariables<VariablesType extends GraphQLVariables>(\n  variables: VariablesType,\n  map: GraphQLParsedOperationsMap,\n  files: Record<string, File>,\n) {\n  const operations = { variables }\n  for (const [key, pathArray] of Object.entries(map)) {\n    if (!(key in files)) {\n      throw new Error(`Given files do not have a key '${key}' .`)\n    }\n\n    for (const dotPath of pathArray) {\n      const [lastPath, ...reversedPaths] = dotPath.split('.').reverse()\n      const paths = reversedPaths.reverse()\n      let target: Record<string, any> = operations\n\n      for (const path of paths) {\n        if (!(path in target)) {\n          throw new Error(`Property '${paths}' is not in operations.`)\n        }\n\n        target = target[path]\n      }\n\n      target[lastPath] = files[key]\n    }\n  }\n  return operations.variables\n}\n\nfunction getGraphQLInput(request: MockedRequest<any>): GraphQLInput | null {\n  switch (request.method) {\n    case 'GET': {\n      const query = request.url.searchParams.get('query')\n      const variables = request.url.searchParams.get('variables') || ''\n\n      return {\n        query,\n        variables: jsonParse(variables),\n      }\n    }\n\n    case 'POST': {\n      if (request.body?.query) {\n        const { query, variables } = request.body\n\n        return {\n          query,\n          variables,\n        }\n      }\n\n      // Handle multipart body operations.\n      if (request.body?.operations) {\n        const { operations, map, ...files } =\n          request.body as GraphQLMultipartRequestBody\n        const parsedOperations =\n          jsonParse<{ query?: string; variables?: GraphQLVariables }>(\n            operations,\n          ) || {}\n\n        if (!parsedOperations.query) {\n          return null\n        }\n\n        const parsedMap = jsonParse<GraphQLParsedOperationsMap>(map || '') || {}\n        const variables = parsedOperations.variables\n          ? extractMultipartVariables(\n              parsedOperations.variables,\n              parsedMap,\n              files,\n            )\n          : {}\n\n        return {\n          query: parsedOperations.query,\n          variables,\n        }\n      }\n    }\n\n    default:\n      return null\n  }\n}\n\n/**\n * Determines if a given request can be considered a GraphQL request.\n * Does not parse the query and does not guarantee its validity.\n */\nexport function parseGraphQLRequest(\n  request: MockedRequest<any>,\n): ParsedGraphQLRequest {\n  const input = getGraphQLInput(request)\n\n  if (!input || !input.query) {\n    return undefined\n  }\n\n  const { query, variables } = input\n  const parsedResult = parseQuery(query)\n\n  if (parsedResult instanceof Error) {\n    const requestPublicUrl = getPublicUrlFromRequest(request)\n\n    throw new Error(\n      devUtils.formatMessage(\n        'Failed to intercept a GraphQL request to \"%s %s\": cannot parse query. See the error message from the parser below.\\n\\n%s',\n        request.method,\n        requestPublicUrl,\n        parsedResult.message,\n      ),\n    )\n  }\n\n  return {\n    operationType: parsedResult.operationType,\n    operationName: parsedResult.operationName,\n    variables,\n  }\n}\n","import { MockedRequest } from './MockedRequest'\n\n/**\n * Returns a relative URL if the given request URL is relative to the current origin.\n * Otherwise returns an absolute URL.\n */\nexport const getPublicUrlFromRequest = (request: MockedRequest) => {\n  return request.referrer.startsWith(request.url.origin)\n    ? request.url.pathname\n    : new URL(\n        request.url.pathname,\n        `${request.url.protocol}//${request.url.host}`,\n      ).href\n}\n","export enum StatusCodeColor {\n  Success = '#69AB32',\n  Warning = '#F0BB4B',\n  Danger = '#E95F5D',\n}\n\n/**\n * Returns a HEX color for a given response status code number.\n */\nexport function getStatusCodeColor(status: number): StatusCodeColor {\n  if (status < 300) {\n    return StatusCodeColor.Success\n  }\n\n  if (status < 400) {\n    return StatusCodeColor.Warning\n  }\n\n  return StatusCodeColor.Danger\n}\n","/**\n * Returns a timestamp string in a \"HH:MM:SS\" format.\n */\nexport function getTimestamp(): string {\n  const now = new Date()\n\n  return [now.getHours(), now.getMinutes(), now.getSeconds()]\n    .map(String)\n    .map((chunk) => chunk.slice(0, 2))\n    .map((chunk) => chunk.padStart(2, '0'))\n    .join(':')\n}\n","import type { DefaultBodyType } from '../../handlers/RequestHandler.js'\nimport type { MockedRequest } from '../request/MockedRequest.js'\n\nexport interface LoggedRequest {\n  id: string\n  url: URL\n  method: string\n  headers: Record<string, string>\n  cookies: Record<string, string>\n  body: DefaultBodyType\n}\n\n/**\n * Formats a mocked request for introspection in browser's console.\n */\nexport function prepareRequest(request: MockedRequest): LoggedRequest {\n  return {\n    ...request,\n    body: request.body,\n    headers: request.headers.all(),\n  }\n}\n","import { objectToHeaders } from 'headers-polyfill'\nimport { SerializedResponse } from '../../setupWorker/glossary'\nimport { parseBody } from '../request/parseBody'\n\n/**\n * Formats a mocked response for introspection in the browser's console.\n */\nexport function prepareResponse(res: SerializedResponse<any>) {\n  const responseHeaders = objectToHeaders(res.headers)\n\n  return {\n    ...res,\n    // Parse a response JSON body for preview in the logs\n    body: parseBody(res.body, responseHeaders),\n  }\n}\n","import { match } from 'path-to-regexp'\nimport { getCleanUrl } from '@mswjs/interceptors/lib/utils/getCleanUrl'\nimport { normalizePath } from './normalizePath'\n\nexport type Path = string | RegExp\nexport type PathParams<KeyType extends keyof any = string> = {\n  [ParamName in KeyType]: string | ReadonlyArray<string>\n}\n\nexport interface Match {\n  matches: boolean\n  params?: PathParams\n}\n\n/**\n * Coerce a path supported by MSW into a path\n * supported by \"path-to-regexp\".\n */\nexport function coercePath(path: string): string {\n  return (\n    path\n      /**\n       * Replace wildcards (\"*\") with unnamed capturing groups\n       * because \"path-to-regexp\" doesn't support wildcards.\n       * Ignore path parameter' modifiers (i.e. \":name*\").\n       */\n      .replace(\n        /([:a-zA-Z_-]*)(\\*{1,2})+/g,\n        (_, parameterName: string | undefined, wildcard: string) => {\n          const expression = '(.*)'\n\n          if (!parameterName) {\n            return expression\n          }\n\n          return parameterName.startsWith(':')\n            ? `${parameterName}${wildcard}`\n            : `${parameterName}${expression}`\n        },\n      )\n      /**\n       * Escape the port so that \"path-to-regexp\" can match\n       * absolute URLs including port numbers.\n       */\n      .replace(/([^\\/])(:)(?=\\d+)/, '$1\\\\$2')\n      /**\n       * Escape the protocol so that \"path-to-regexp\" could match\n       * absolute URL.\n       * @see https://github.com/pillarjs/path-to-regexp/issues/259\n       */\n      .replace(/^([^\\/]+)(:)(?=\\/\\/)/, '$1\\\\$2')\n  )\n}\n\n/**\n * Returns the result of matching given request URL against a mask.\n */\nexport function matchRequestUrl(url: URL, path: Path, baseUrl?: string): Match {\n  const normalizedPath = normalizePath(path, baseUrl)\n  const cleanPath =\n    typeof normalizedPath === 'string'\n      ? coercePath(normalizedPath)\n      : normalizedPath\n\n  const cleanUrl = getCleanUrl(url)\n  const result = match(cleanPath, { decode: decodeURIComponent })(cleanUrl)\n  const params = (result && (result.params as PathParams)) || {}\n\n  return {\n    matches: result !== false,\n    params,\n  }\n}\n","const REDUNDANT_CHARACTERS_EXP = /[\\?|#].*$/g\n\nexport function getSearchParams(path: string) {\n  return new URL(`/${path}`, 'http://localhost').searchParams\n}\n\n/**\n * Removes query parameters and hashes from a given URL string.\n */\nexport function cleanUrl(path: string): string {\n  return path.replace(REDUNDANT_CHARACTERS_EXP, '')\n}\n","/**\n * Determines if the given URL string is an absolute URL.\n */\nexport function isAbsoluteUrl(url: string): boolean {\n  return /^([a-z][a-z\\d\\+\\-\\.]*:)?\\/\\//i.test(url)\n}\n","import { isAbsoluteUrl } from './isAbsoluteUrl'\n\n/**\n * Returns an absolute URL based on the given path.\n */\nexport function getAbsoluteUrl(path: string, baseUrl?: string): string {\n  // already absolute URL\n  if (isAbsoluteUrl(path)) {\n    return path\n  }\n\n  // Ignore path with pattern start with *\n  if (path.startsWith('*')) {\n    return path\n  }\n\n  // Resolve a relative request URL against a given custom \"baseUrl\"\n  // or the document baseURI (in the case of browser/browser-like environments).\n  const origin =\n    baseUrl || (typeof document !== 'undefined' && document.baseURI)\n\n  return origin\n    ? // Encode and decode the path to preserve escaped characters.\n      decodeURI(new URL(encodeURI(path), origin).href)\n    : path\n}\n","import type { Path } from './matchRequestUrl'\nimport { cleanUrl } from '../url/cleanUrl'\nimport { getAbsoluteUrl } from '../url/getAbsoluteUrl'\n\n/**\n * Normalizes a given request handler path:\n * - Preserves RegExp.\n * - Removes query parameters and hashes.\n * - Rebases relative URLs against the \"baseUrl\" or the current location.\n * - Preserves relative URLs in Node.js, unless specified otherwise.\n */\nexport function normalizePath(path: Path, baseUrl?: string): Path {\n  // RegExp paths do not need normalization.\n  if (path instanceof RegExp) {\n    return path\n  }\n\n  const maybeAbsoluteUrl = getAbsoluteUrl(path, baseUrl)\n\n  return cleanUrl(maybeAbsoluteUrl)\n}\n","import { Headers } from 'headers-polyfill'\nimport {\n  MaybePromise,\n  MockedResponse,\n  response,\n  ResponseComposition,\n} from '../response'\nimport { getCallFrame } from '../utils/internal/getCallFrame'\nimport { isIterable } from '../utils/internal/isIterable'\nimport { status } from '../context/status'\nimport { set } from '../context/set'\nimport { delay } from '../context/delay'\nimport { fetch } from '../context/fetch'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nexport type DefaultContext = {\n  status: typeof status\n  set: typeof set\n  delay: typeof delay\n  fetch: typeof fetch\n}\n\nexport const defaultContext: DefaultContext = {\n  status,\n  set,\n  delay,\n  fetch,\n}\n\nexport type DefaultRequestMultipartBody = Record<\n  string,\n  string | File | (string | File)[]\n>\n\nexport type DefaultBodyType =\n  | Record<string, any>\n  | DefaultRequestMultipartBody\n  | string\n  | number\n  | boolean\n  | null\n  | undefined\n\nexport interface RequestHandlerDefaultInfo {\n  header: string\n}\n\nexport interface RequestHandlerInternalInfo {\n  callFrame?: string\n}\n\ntype ContextMap = Record<string, (...args: any[]) => any>\n\nexport type ResponseResolverReturnType<ReturnType> =\n  | ReturnType\n  | undefined\n  | void\n\nexport type MaybeAsyncResponseResolverReturnType<ReturnType> = MaybePromise<\n  ResponseResolverReturnType<ReturnType>\n>\n\nexport type AsyncResponseResolverReturnType<ReturnType> =\n  | MaybeAsyncResponseResolverReturnType<ReturnType>\n  | Generator<\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>,\n      MaybeAsyncResponseResolverReturnType<ReturnType>\n    >\n\nexport type ResponseResolver<\n  RequestType = MockedRequest,\n  ContextType = typeof defaultContext,\n  BodyType extends DefaultBodyType = any,\n> = (\n  req: RequestType,\n  res: ResponseComposition<BodyType>,\n  context: ContextType,\n) => AsyncResponseResolverReturnType<MockedResponse<BodyType>>\n\nexport interface RequestHandlerOptions<HandlerInfo> {\n  info: HandlerInfo\n  resolver: ResponseResolver<any, any>\n  ctx?: ContextMap\n}\n\nexport interface RequestHandlerExecutionResult<PublicRequestType> {\n  handler: RequestHandler\n  parsedResult: any\n  request: PublicRequestType\n  response?: MockedResponse\n}\n\nexport abstract class RequestHandler<\n  HandlerInfo extends RequestHandlerDefaultInfo = RequestHandlerDefaultInfo,\n  Request extends MockedRequest = MockedRequest,\n  ParsedResult = any,\n  PublicRequest extends MockedRequest = Request,\n> {\n  public info: HandlerInfo & RequestHandlerInternalInfo\n  public shouldSkip: boolean\n\n  private ctx: ContextMap\n  private resolverGenerator?: Generator<\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>,\n    MaybeAsyncResponseResolverReturnType<any>\n  >\n  private resolverGeneratorResult?: MaybeAsyncResponseResolverReturnType<any>\n\n  protected resolver: ResponseResolver<any, any>\n\n  constructor(options: RequestHandlerOptions<HandlerInfo>) {\n    this.shouldSkip = false\n    this.ctx = options.ctx || defaultContext\n    this.resolver = options.resolver\n\n    const callFrame = getCallFrame(new Error())\n\n    this.info = {\n      ...options.info,\n      callFrame,\n    }\n  }\n\n  /**\n   * Determine if the captured request should be mocked.\n   */\n  abstract predicate(\n    request: MockedRequest,\n    parsedResult: ParsedResult,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean\n\n  /**\n   * Print out the successfully handled request.\n   */\n  abstract log(\n    request: Request,\n    response: SerializedResponse<any>,\n    parsedResult: ParsedResult,\n  ): void\n\n  /**\n   * Parse the captured request to extract additional information from it.\n   * Parsed result is then exposed to other methods of this request handler.\n   */\n  parse(\n    _request: MockedRequest,\n    _resolutionContext?: ResponseResolutionContext,\n  ): ParsedResult {\n    return null as any\n  }\n\n  /**\n   * Test if this handler matches the given request.\n   */\n  public test(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): boolean {\n    return this.predicate(\n      request,\n      this.parse(request, resolutionContext),\n      resolutionContext,\n    )\n  }\n\n  /**\n   * Derive the publicly exposed request (`req`) instance of the response resolver\n   * from the captured request and its parsed result.\n   */\n  protected getPublicRequest(\n    request: MockedRequest,\n    _parsedResult: ParsedResult,\n  ) {\n    return request as PublicRequest\n  }\n\n  public markAsSkipped(shouldSkip = true) {\n    this.shouldSkip = shouldSkip\n  }\n\n  /**\n   * Execute this request handler and produce a mocked response\n   * using the given resolver function.\n   */\n  public async run(\n    request: MockedRequest,\n    resolutionContext?: ResponseResolutionContext,\n  ): Promise<RequestHandlerExecutionResult<PublicRequest> | null> {\n    if (this.shouldSkip) {\n      return null\n    }\n\n    const parsedResult = this.parse(request, resolutionContext)\n    const shouldIntercept = this.predicate(\n      request,\n      parsedResult,\n      resolutionContext,\n    )\n\n    if (!shouldIntercept) {\n      return null\n    }\n\n    const publicRequest = this.getPublicRequest(request, parsedResult)\n\n    // Create a response extraction wrapper around the resolver\n    // since it can be both an async function and a generator.\n    const executeResolver = this.wrapResolver(this.resolver)\n    const mockedResponse = await executeResolver(\n      publicRequest,\n      response,\n      this.ctx,\n    )\n\n    return this.createExecutionResult(\n      parsedResult,\n      publicRequest,\n      mockedResponse,\n    )\n  }\n\n  private wrapResolver(\n    resolver: ResponseResolver<any, any>,\n  ): ResponseResolver<AsyncResponseResolverReturnType<any>, any> {\n    return async (req, res, ctx) => {\n      const result = this.resolverGenerator || (await resolver(req, res, ctx))\n\n      if (isIterable<AsyncResponseResolverReturnType<any>>(result)) {\n        const { value, done } = result[Symbol.iterator]().next()\n        const nextResponse = await value\n\n        // If the generator is done and there is no next value,\n        // return the previous generator's value.\n        if (!nextResponse && done) {\n          return this.resolverGeneratorResult\n        }\n\n        if (!this.resolverGenerator) {\n          this.resolverGenerator = result\n        }\n\n        this.resolverGeneratorResult = nextResponse\n        return nextResponse\n      }\n\n      return result\n    }\n  }\n\n  private createExecutionResult(\n    parsedResult: ParsedResult,\n    request: PublicRequest,\n    response: any,\n  ): RequestHandlerExecutionResult<PublicRequest> {\n    return {\n      handler: this,\n      parsedResult: parsedResult || null,\n      request,\n      response: response || null,\n    }\n  }\n}\n\n/**\n * Bypass this intercepted request.\n * This will make a call to the actual endpoint requested.\n */\nexport function passthrough(): MockedResponse<null> {\n  // Constructing a dummy \"101 Continue\" mocked response\n  // to keep the return type of the resolver consistent.\n  return {\n    status: 101,\n    statusText: 'Continue',\n    headers: new Headers(),\n    body: null,\n    // Setting \"passthrough\" to true will signal the response pipeline\n    // to perform this intercepted request as-is.\n    passthrough: true,\n    once: false,\n  }\n}\n","import { Headers } from 'headers-polyfill'\nimport { DefaultBodyType } from './handlers/RequestHandler'\nimport { compose } from './utils/internal/compose'\nimport { NetworkError } from './utils/NetworkError'\n\nexport type MaybePromise<ValueType = any> = ValueType | Promise<ValueType>\n\n/**\n * Internal representation of a mocked response instance.\n */\nexport interface MockedResponse<BodyType extends DefaultBodyType = any> {\n  body: BodyType\n  status: number\n  statusText: string\n  headers: Headers\n  once: boolean\n  passthrough: boolean\n  delay?: number\n}\n\nexport type ResponseTransformer<\n  BodyType extends TransformerBodyType = any,\n  TransformerBodyType extends DefaultBodyType = any,\n> = (\n  res: MockedResponse<TransformerBodyType>,\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseFunction<BodyType extends DefaultBodyType = any> = (\n  ...transformers: ResponseTransformer<BodyType>[]\n) => MaybePromise<MockedResponse<BodyType>>\n\nexport type ResponseComposition<BodyType extends DefaultBodyType = any> =\n  ResponseFunction<BodyType> & {\n    /**\n     * Respond using a given mocked response to the first captured request.\n     * Does not affect any subsequent captured requests.\n     */\n    once: ResponseFunction<BodyType>\n    networkError: (message: string) => void\n  }\n\nexport const defaultResponse: Omit<MockedResponse, 'headers'> = {\n  status: 200,\n  statusText: 'OK',\n  body: null,\n  delay: 0,\n  once: false,\n  passthrough: false,\n}\n\nexport type ResponseCompositionOptions<BodyType> = {\n  defaultTransformers?: ResponseTransformer<BodyType>[]\n  mockedResponseOverrides?: Partial<MockedResponse>\n}\n\nexport const defaultResponseTransformers: ResponseTransformer<any>[] = []\n\nexport function createResponseComposition<BodyType extends DefaultBodyType>(\n  responseOverrides?: Partial<MockedResponse<BodyType>>,\n  defaultTransformers: ResponseTransformer<BodyType>[] = defaultResponseTransformers,\n): ResponseFunction {\n  return async (...transformers) => {\n    const initialResponse: MockedResponse = Object.assign(\n      {},\n      defaultResponse,\n      {\n        headers: new Headers({\n          'x-powered-by': 'msw',\n        }),\n      },\n      responseOverrides,\n    )\n\n    const resolvedTransformers = [\n      ...defaultTransformers,\n      ...transformers,\n    ].filter(Boolean)\n\n    const resolvedResponse =\n      resolvedTransformers.length > 0\n        ? compose(...resolvedTransformers)(initialResponse)\n        : initialResponse\n\n    return resolvedResponse\n  }\n}\n\nexport const response = Object.assign(createResponseComposition(), {\n  once: createResponseComposition({ once: true }),\n  networkError(message: string) {\n    throw new NetworkError(message)\n  },\n})\n","type ArityOneFunction = (arg: any) => any\n\ntype LengthOfTuple<Tuple extends any[]> = Tuple extends { length: infer L }\n  ? L\n  : never\n\ntype DropFirstInTuple<Tuple extends any[]> = ((...args: Tuple) => any) extends (\n  arg: any,\n  ...rest: infer LastArg\n) => any\n  ? LastArg\n  : Tuple\n\ntype LastInTuple<Tuple extends any[]> = Tuple[LengthOfTuple<\n  DropFirstInTuple<Tuple>\n>]\n\ntype FirstFnParameterType<Functions extends ArityOneFunction[]> = Parameters<\n  LastInTuple<Functions>\n>[any]\n\ntype LastFnParameterType<Functions extends ArityOneFunction[]> = ReturnType<\n  Functions[0]\n>\n\n/**\n * Composes a given list of functions into a new function that\n * executes from right to left.\n */\nexport function compose<\n  Functions extends ArityOneFunction[],\n  LeftReturnType extends FirstFnParameterType<Functions>,\n  RightReturnType extends LastFnParameterType<Functions>,\n>(\n  ...fns: Functions\n): (\n  ...args: [LeftReturnType] extends [never] ? never[] : [LeftReturnType]\n) => RightReturnType {\n  return (...args) => {\n    return fns.reduceRight((leftFn: any, rightFn) => {\n      return leftFn instanceof Promise\n        ? Promise.resolve(leftFn).then(rightFn)\n        : rightFn(leftFn)\n    }, args[0])\n  }\n}\n","// Ignore the source files traces for local testing.\nconst SOURCE_FRAME = /\\/msw\\/src\\/(.+)/\n\nconst BUILD_FRAME =\n  /(node_modules)?[\\/\\\\]lib[\\/\\\\](umd|esm|iief|cjs)[\\/\\\\]|^[^\\/\\\\]*$/\n\n/**\n * Return the stack trace frame of a function's invocation.\n */\nexport function getCallFrame(error: Error) {\n  // In <IE11, new Error may return an undefined stack\n  const stack = error.stack\n\n  if (!stack) {\n    return\n  }\n\n  const frames: string[] = stack.split('\\n').slice(1)\n\n  // Get the first frame that doesn't reference the library's internal trace.\n  // Assume that frame is the invocation frame.\n  const declarationFrame = frames.find((frame) => {\n    return !(SOURCE_FRAME.test(frame) || BUILD_FRAME.test(frame))\n  })\n\n  if (!declarationFrame) {\n    return\n  }\n\n  // Extract file reference from the stack frame.\n  const declarationPath = declarationFrame\n    .replace(/\\s*at [^()]*\\(([^)]+)\\)/, '$1')\n    .replace(/^@/, '')\n  return declarationPath\n}\n","/**\n * Determines if the given function is an iterator.\n */\nexport function isIterable<IteratorType>(\n  fn: any,\n): fn is Generator<IteratorType, IteratorType, IteratorType> {\n  if (!fn) {\n    return false\n  }\n\n  return typeof (fn as Generator<unknown>)[Symbol.iterator] == 'function'\n}\n","import { body, cookie, json, text, xml } from '../context'\nimport type { SerializedResponse } from '../setupWorker/glossary'\nimport { ResponseResolutionContext } from '../utils/getResponse'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { isStringEqual } from '../utils/internal/isStringEqual'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport {\n  Match,\n  matchRequestUrl,\n  Path,\n  PathParams,\n} from '../utils/matching/matchRequestUrl'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { MockedRequest } from '../utils/request/MockedRequest'\nimport { cleanUrl, getSearchParams } from '../utils/url/cleanUrl'\nimport {\n  DefaultBodyType,\n  defaultContext,\n  DefaultContext,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\n\ntype RestHandlerMethod = string | RegExp\n\nexport interface RestHandlerInfo extends RequestHandlerDefaultInfo {\n  method: RestHandlerMethod\n  path: Path\n}\n\nexport enum RESTMethods {\n  HEAD = 'HEAD',\n  GET = 'GET',\n  POST = 'POST',\n  PUT = 'PUT',\n  PATCH = 'PATCH',\n  OPTIONS = 'OPTIONS',\n  DELETE = 'DELETE',\n}\n\n// Declaring a context interface infers\n// JSDoc description of the referenced utils.\nexport type RestContext = DefaultContext & {\n  cookie: typeof cookie\n  text: typeof text\n  body: typeof body\n  json: typeof json\n  xml: typeof xml\n}\n\nexport const restContext: RestContext = {\n  ...defaultContext,\n  cookie,\n  body,\n  text,\n  json,\n  xml,\n}\n\nexport type RequestQuery = {\n  [queryName: string]: string\n}\n\nexport type ParsedRestRequest = Match\n\nexport class RestRequest<\n  RequestBody extends DefaultBodyType = DefaultBodyType,\n  RequestParams extends PathParams = PathParams,\n> extends MockedRequest<RequestBody> {\n  constructor(\n    request: MockedRequest<RequestBody>,\n    public readonly params: RequestParams,\n  ) {\n    super(request.url, {\n      ...request,\n      /**\n       * @deprecated https://github.com/mswjs/msw/issues/1318\n       * @note Use internal request body buffer as the body init\n       * because \"request.body\" is a getter that will trigger\n       * request body parsing at this step.\n       */\n      body: request['_body'],\n    })\n    this.id = request.id\n  }\n}\n\n/**\n * Request handler for REST API requests.\n * Provides request matching based on method and URL.\n */\nexport class RestHandler<\n  RequestType extends MockedRequest<DefaultBodyType> = MockedRequest<DefaultBodyType>,\n> extends RequestHandler<\n  RestHandlerInfo,\n  RequestType,\n  ParsedRestRequest,\n  RestRequest<\n    RequestType extends MockedRequest<infer RequestBodyType>\n      ? RequestBodyType\n      : any,\n    PathParams\n  >\n> {\n  constructor(\n    method: RestHandlerMethod,\n    path: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    super({\n      info: {\n        header: `${method} ${path}`,\n        path,\n        method,\n      },\n      ctx: restContext,\n      resolver,\n    })\n\n    this.checkRedundantQueryParameters()\n  }\n\n  private checkRedundantQueryParameters() {\n    const { method, path } = this.info\n\n    if (path instanceof RegExp) {\n      return\n    }\n\n    const url = cleanUrl(path)\n\n    // Bypass request handler URLs that have no redundant characters.\n    if (url === path) {\n      return\n    }\n\n    const searchParams = getSearchParams(path)\n    const queryParams: string[] = []\n\n    searchParams.forEach((_, paramName) => {\n      queryParams.push(paramName)\n    })\n\n    devUtils.warn(\n      `Found a redundant usage of query parameters in the request handler URL for \"${method} ${path}\". Please match against a path instead and access query parameters in the response resolver function using \"req.url.searchParams\".`,\n    )\n  }\n\n  parse(request: RequestType, resolutionContext?: ResponseResolutionContext) {\n    return matchRequestUrl(\n      request.url,\n      this.info.path,\n      resolutionContext?.baseUrl,\n    )\n  }\n\n  protected getPublicRequest(\n    request: RequestType,\n    parsedResult: ParsedRestRequest,\n  ): RestRequest<any, PathParams> {\n    return new RestRequest(request, parsedResult.params || {})\n  }\n\n  predicate(request: RequestType, parsedResult: ParsedRestRequest) {\n    const matchesMethod =\n      this.info.method instanceof RegExp\n        ? this.info.method.test(request.method)\n        : isStringEqual(this.info.method, request.method)\n\n    return matchesMethod && parsedResult.matches\n  }\n\n  log(request: RequestType, response: SerializedResponse<any>) {\n    const publicUrl = getPublicUrlFromRequest(request)\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s %s (%c%s%c)'),\n      getTimestamp(),\n      request.method,\n      publicUrl,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request', loggedRequest)\n    console.log('Handler:', this)\n    console.log('Response', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { invariant } from 'outvariant'\nimport { ResponseTransformer } from '../response'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { jsonParse } from '../utils/internal/jsonParse'\nimport { mergeRight } from '../utils/internal/mergeRight'\nimport { json } from './json'\n\ntype ForbiddenFieldNames = '' | 'data' | 'errors' | 'extensions'\n\n/**\n * Set a custom field on the GraphQL mocked response.\n * @example res(ctx.fields('customField', value))\n * @see {@link https://mswjs.io/docs/api/context/field}\n */\nexport const field = <FieldNameType extends string, FieldValueType>(\n  fieldName: FieldNameType extends ForbiddenFieldNames ? never : FieldNameType,\n  fieldValue: FieldValueType,\n): ResponseTransformer<string> => {\n  return (res) => {\n    validateFieldName(fieldName)\n\n    const prevBody = jsonParse(res.body) || {}\n    const nextBody = mergeRight(prevBody, { [fieldName]: fieldValue })\n\n    return json(nextBody)(res as any) as any\n  }\n}\n\nfunction validateFieldName(fieldName: string) {\n  invariant(\n    fieldName.trim() !== '',\n    devUtils.formatMessage(\n      'Failed to set a custom field on a GraphQL response: field name cannot be empty.',\n    ),\n  )\n\n  invariant(\n    fieldName !== 'data',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.data()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'errors',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.errors()\" instead?',\n      fieldName,\n    ),\n  )\n\n  invariant(\n    fieldName !== 'extensions',\n    devUtils.formatMessage(\n      'Failed to set a custom \"%s\" field on a mocked GraphQL response: forbidden field name. Did you mean to call \"ctx.extensions()\" instead?',\n      fieldName,\n    ),\n  )\n}\n","export function tryCatch<Fn extends (...args: any[]) => any>(\n  fn: Fn,\n  onException?: (error: Error) => void,\n): ReturnType<Fn> | undefined {\n  try {\n    const result = fn()\n    return result\n  } catch (error) {\n    onException?.(error as Error)\n  }\n}\n","import type { DocumentNode, OperationTypeNode } from 'graphql'\nimport { SerializedResponse } from '../setupWorker/glossary'\nimport { data } from '../context/data'\nimport { extensions } from '../context/extensions'\nimport { errors } from '../context/errors'\nimport { field } from '../context/field'\nimport { GraphQLPayloadContext } from '../typeUtils'\nimport { cookie } from '../context/cookie'\nimport {\n  defaultContext,\n  DefaultContext,\n  RequestHandler,\n  RequestHandlerDefaultInfo,\n  ResponseResolver,\n} from './RequestHandler'\nimport { getTimestamp } from '../utils/logging/getTimestamp'\nimport { getStatusCodeColor } from '../utils/logging/getStatusCodeColor'\nimport { prepareRequest } from '../utils/logging/prepareRequest'\nimport { prepareResponse } from '../utils/logging/prepareResponse'\nimport { matchRequestUrl, Path } from '../utils/matching/matchRequestUrl'\nimport {\n  ParsedGraphQLRequest,\n  GraphQLMultipartRequestBody,\n  parseGraphQLRequest,\n  parseDocumentNode,\n} from '../utils/internal/parseGraphQLRequest'\nimport { getPublicUrlFromRequest } from '../utils/request/getPublicUrlFromRequest'\nimport { tryCatch } from '../utils/internal/tryCatch'\nimport { devUtils } from '../utils/internal/devUtils'\nimport { MockedRequest } from '../utils/request/MockedRequest'\n\nexport type ExpectedOperationTypeNode = OperationTypeNode | 'all'\nexport type GraphQLHandlerNameSelector = DocumentNode | RegExp | string\n\n// GraphQL related context should contain utility functions\n// useful for GraphQL. Functions like `xml()` bear no value\n// in the GraphQL universe.\nexport type GraphQLContext<QueryType extends Record<string, unknown>> =\n  DefaultContext & {\n    data: GraphQLPayloadContext<QueryType>\n    extensions: GraphQLPayloadContext<QueryType>\n    errors: typeof errors\n    cookie: typeof cookie\n    field: typeof field\n  }\n\nexport const graphqlContext: GraphQLContext<any> = {\n  ...defaultContext,\n  data,\n  extensions,\n  errors,\n  cookie,\n  field,\n}\n\nexport type GraphQLVariables = Record<string, any>\n\nexport interface GraphQLHandlerInfo extends RequestHandlerDefaultInfo {\n  operationType: ExpectedOperationTypeNode\n  operationName: GraphQLHandlerNameSelector\n}\n\nexport type GraphQLRequestBody<VariablesType extends GraphQLVariables> =\n  | GraphQLJsonRequestBody<VariablesType>\n  | GraphQLMultipartRequestBody\n  | Record<string, any>\n  | undefined\n\nexport interface GraphQLJsonRequestBody<Variables extends GraphQLVariables> {\n  query: string\n  variables?: Variables\n}\n\nexport function isDocumentNode(\n  value: DocumentNode | any,\n): value is DocumentNode {\n  if (value == null) {\n    return false\n  }\n\n  return typeof value === 'object' && 'kind' in value && 'definitions' in value\n}\n\nexport class GraphQLRequest<\n  Variables extends GraphQLVariables,\n> extends MockedRequest<GraphQLRequestBody<Variables>> {\n  constructor(request: MockedRequest, public readonly variables: Variables) {\n    super(request.url, {\n      ...request,\n      /**\n       * TODO(https://github.com/mswjs/msw/issues/1318): Cleanup\n       */\n      body: request['_body'],\n    })\n  }\n}\n\nexport class GraphQLHandler<\n  Request extends GraphQLRequest<any> = GraphQLRequest<any>,\n> extends RequestHandler<\n  GraphQLHandlerInfo,\n  Request,\n  ParsedGraphQLRequest | null,\n  GraphQLRequest<any>\n> {\n  private endpoint: Path\n\n  constructor(\n    operationType: ExpectedOperationTypeNode,\n    operationName: GraphQLHandlerNameSelector,\n    endpoint: Path,\n    resolver: ResponseResolver<any, any>,\n  ) {\n    let resolvedOperationName = operationName\n\n    if (isDocumentNode(operationName)) {\n      const parsedNode = parseDocumentNode(operationName)\n\n      if (parsedNode.operationType !== operationType) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with a mismatched operation type (expected \"${operationType}\", but got \"${parsedNode.operationType}\").`,\n        )\n      }\n\n      if (!parsedNode.operationName) {\n        throw new Error(\n          `Failed to create a GraphQL handler: provided a DocumentNode with no operation name.`,\n        )\n      }\n\n      resolvedOperationName = parsedNode.operationName\n    }\n\n    const header =\n      operationType === 'all'\n        ? `${operationType} (origin: ${endpoint.toString()})`\n        : `${operationType} ${resolvedOperationName} (origin: ${endpoint.toString()})`\n\n    super({\n      info: {\n        header,\n        operationType,\n        operationName: resolvedOperationName,\n      },\n      ctx: graphqlContext,\n      resolver,\n    })\n\n    this.endpoint = endpoint\n  }\n\n  parse(request: MockedRequest) {\n    return tryCatch(\n      () => parseGraphQLRequest(request),\n      (error) => console.error(error.message),\n    )\n  }\n\n  protected getPublicRequest(\n    request: Request,\n    parsedResult: ParsedGraphQLRequest,\n  ): GraphQLRequest<any> {\n    return new GraphQLRequest(request, parsedResult?.variables || {})\n  }\n\n  predicate(request: MockedRequest, parsedResult: ParsedGraphQLRequest) {\n    if (!parsedResult) {\n      return false\n    }\n\n    if (!parsedResult.operationName && this.info.operationType !== 'all') {\n      const publicUrl = getPublicUrlFromRequest(request)\n      devUtils.warn(`\\\nFailed to intercept a GraphQL request at \"${request.method} ${publicUrl}\": anonymous GraphQL operations are not supported.\n\nConsider naming this operation or using \"graphql.operation\" request handler to intercept GraphQL requests regardless of their operation name/type. Read more: https://mswjs.io/docs/api/graphql/operation\\\n      `)\n      return false\n    }\n\n    const hasMatchingUrl = matchRequestUrl(request.url, this.endpoint)\n    const hasMatchingOperationType =\n      this.info.operationType === 'all' ||\n      parsedResult.operationType === this.info.operationType\n\n    const hasMatchingOperationName =\n      this.info.operationName instanceof RegExp\n        ? this.info.operationName.test(parsedResult.operationName || '')\n        : parsedResult.operationName === this.info.operationName\n\n    return (\n      hasMatchingUrl.matches &&\n      hasMatchingOperationType &&\n      hasMatchingOperationName\n    )\n  }\n\n  log(\n    request: Request,\n    response: SerializedResponse<any>,\n    parsedRequest: ParsedGraphQLRequest,\n  ) {\n    const loggedRequest = prepareRequest(request)\n    const loggedResponse = prepareResponse(response)\n    const statusColor = getStatusCodeColor(response.status)\n    const requestInfo = parsedRequest?.operationName\n      ? `${parsedRequest?.operationType} ${parsedRequest?.operationName}`\n      : `anonymous ${parsedRequest?.operationType}`\n\n    console.groupCollapsed(\n      devUtils.formatMessage('%s %s (%c%s%c)'),\n      getTimestamp(),\n      `${requestInfo}`,\n      `color:${statusColor}`,\n      `${response.status} ${response.statusText}`,\n      'color:inherit',\n    )\n    console.log('Request:', loggedRequest)\n    console.log('Handler:', this)\n    console.log('Response:', loggedResponse)\n    console.groupEnd()\n  }\n}\n","import { store } from '@mswjs/cookies'\nimport { MockedResponse } from '../../response'\nimport { MockedRequest } from './MockedRequest'\n\nexport function readResponseCookies(\n  request: MockedRequest,\n  response: MockedResponse,\n) {\n  store.add({ ...request, url: request.url.toString() }, response)\n  store.persist()\n}\n","import { flattenHeadersObject, headersToObject } from 'headers-polyfill'\nimport type { SerializedResponse } from '../../setupWorker/glossary'\n\nexport function serializeResponse(source: Response): SerializedResponse<any> {\n  return {\n    status: source.status,\n    statusText: source.statusText,\n    headers: flattenHeadersObject(headersToObject(source.headers)),\n    body: source.body,\n  }\n}\n","import {\n  StartOptions,\n  SerializedResponse,\n  SetupWorkerInternalContext,\n  ServiceWorkerIncomingEventsMap,\n} from '../glossary'\nimport {\n  ServiceWorkerMessage,\n  WorkerChannel,\n} from './utils/createMessageChannel'\nimport { NetworkError } from '../../utils/NetworkError'\nimport { parseWorkerRequest } from '../../utils/request/parseWorkerRequest'\nimport { handleRequest } from '../../utils/handleRequest'\nimport { RequiredDeep } from '../../typeUtils'\nimport { MockedResponse } from '../../response'\nimport { devUtils } from '../../utils/internal/devUtils'\nimport { serializeResponse } from '../../utils/logging/serializeResponse'\n\nexport const createRequestListener = (\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n) => {\n  return async (\n    event: MessageEvent,\n    message: ServiceWorkerMessage<\n      'REQUEST',\n      ServiceWorkerIncomingEventsMap['REQUEST']\n    >,\n  ) => {\n    const messageChannel = new WorkerChannel(event.ports[0])\n    const request = parseWorkerRequest(message.payload)\n\n    try {\n      await handleRequest<SerializedResponse>(\n        request,\n        context.requestHandlers,\n        options,\n        context.emitter,\n        {\n          transformResponse,\n          onPassthroughResponse() {\n            messageChannel.postMessage('NOT_FOUND')\n          },\n          async onMockedResponse(\n            response,\n            { handler, publicRequest, parsedRequest },\n          ) {\n            if (response.body instanceof ReadableStream) {\n              throw new Error(\n                devUtils.formatMessage(\n                  'Failed to construct a mocked response with a \"ReadableStream\" body: mocked streams are not supported. Follow https://github.com/mswjs/msw/issues/1336 for more details.',\n                ),\n              )\n            }\n\n            const responseInstance = new Response(response.body, response)\n            const responseBodyBuffer = await responseInstance.arrayBuffer()\n\n            // If the mocked response has no body, keep it that way.\n            // Sending an empty \"ArrayBuffer\" to the worker will cause\n            // the worker constructing \"new Response(new ArrayBuffer(0))\"\n            // which will throw on responses that must have no body (i.e. 204).\n            const responseBody =\n              response.body == null ? null : responseBodyBuffer\n\n            messageChannel.postMessage(\n              'MOCK_RESPONSE',\n              {\n                ...response,\n                body: responseBody,\n              },\n              [responseBodyBuffer],\n            )\n\n            if (!options.quiet) {\n              context.emitter.once('response:mocked', (response) => {\n                handler.log(\n                  publicRequest,\n                  serializeResponse(response),\n                  parsedRequest,\n                )\n              })\n            }\n          },\n        },\n      )\n    } catch (error) {\n      if (error instanceof NetworkError) {\n        // Treat emulated network error differently,\n        // as it is an intended exception in a request handler.\n        messageChannel.postMessage('NETWORK_ERROR', {\n          name: error.name,\n          message: error.message,\n        })\n\n        return\n      }\n\n      if (error instanceof Error) {\n        devUtils.error(\n          `Uncaught exception in the request handler for \"%s %s\":\n\n%s\n\nThis exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,\n          request.method,\n          request.url,\n          error,\n        )\n\n        // Treat all other exceptions in a request handler as unintended,\n        // alerting that there is a problem that needs fixing.\n        messageChannel.postMessage('MOCK_RESPONSE', {\n          status: 500,\n          statusText: 'Request Handler Error',\n          headers: {\n            'Content-Type': 'application/json',\n          },\n          body: JSON.stringify({\n            name: error.name,\n            message: error.message,\n            stack: error.stack,\n          }),\n        })\n      }\n    }\n  }\n}\n\nfunction transformResponse(\n  response: MockedResponse<string>,\n): SerializedResponse<string> {\n  return {\n    status: response.status,\n    statusText: response.statusText,\n    headers: response.headers.all(),\n    body: response.body,\n    delay: response.delay,\n  }\n}\n","import { SetupWorkerInternalContext } from '../../setupWorker/glossary'\n\nexport async function requestIntegrityCheck(\n  context: SetupWorkerInternalContext,\n  serviceWorker: ServiceWorker,\n): Promise<ServiceWorker> {\n  // Signal Service Worker to report back its integrity\n  context.workerChannel.send('INTEGRITY_CHECK_REQUEST')\n\n  const { payload: actualChecksum } = await context.events.once(\n    'INTEGRITY_CHECK_RESPONSE',\n  )\n\n  // Compare the response from the Service Worker and the\n  // global variable set during the build.\n  if (actualChecksum !== SERVICE_WORKER_CHECKSUM) {\n    throw new Error(\n      `Currently active Service Worker (${actualChecksum}) is behind the latest published one (${SERVICE_WORKER_CHECKSUM}).`,\n    )\n  }\n\n  return serviceWorker\n}\n","import { until } from '@open-draft/until'\n\n/**\n * Intercepts and defers any requests on the page\n * until the Service Worker instance is ready.\n * Must only be used in a browser.\n */\nexport function deferNetworkRequestsUntil(predicatePromise: Promise<any>) {\n  // Defer any `XMLHttpRequest` requests until the Service Worker is ready.\n  const originalXhrSend = window.XMLHttpRequest.prototype.send\n  window.XMLHttpRequest.prototype.send = function (\n    ...args: Parameters<XMLHttpRequest['send']>\n  ) {\n    // Keep this function synchronous to comply with `XMLHttpRequest.prototype.send`,\n    // because that method is always synchronous.\n    until(() => predicatePromise).then(() => {\n      window.XMLHttpRequest.prototype.send = originalXhrSend\n      this.send(...args)\n    })\n  }\n\n  // Defer any `fetch` requests until the Service Worker is ready.\n  const originalFetch = window.fetch\n  window.fetch = async (...args) => {\n    await until(() => predicatePromise)\n    window.fetch = originalFetch\n    return window.fetch(...args)\n  }\n}\n","import {\n  ServiceWorkerIncomingEventsMap,\n  SetupWorkerInternalContext,\n} from '../../setupWorker/glossary'\nimport { ServiceWorkerMessage } from './utils/createMessageChannel'\n\nexport function createResponseListener(context: SetupWorkerInternalContext) {\n  return (\n    _: MessageEvent,\n    message: ServiceWorkerMessage<\n      'RESPONSE',\n      ServiceWorkerIncomingEventsMap['RESPONSE']\n    >,\n  ) => {\n    const { payload: responseJson } = message\n\n    /**\n     * CORS requests with `mode: \"no-cors\"` result in \"opaque\" responses.\n     * That kind of responses cannot be manipulated in JavaScript due\n     * to the security considerations.\n     * @see https://fetch.spec.whatwg.org/#concept-filtered-response-opaque\n     * @see https://github.com/mswjs/msw/issues/529\n     */\n    if (responseJson.type?.includes('opaque')) {\n      return\n    }\n\n    const response = new Response(responseJson.body || null, responseJson)\n    const isMockedResponse = response.headers.get('x-powered-by') === 'msw'\n\n    if (isMockedResponse) {\n      context.emitter.emit('response:mocked', response, responseJson.requestId)\n    } else {\n      context.emitter.emit('response:bypass', response, responseJson.requestId)\n    }\n  }\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\nimport { StartOptions } from '../../glossary'\n\nexport function validateWorkerScope(\n  registration: ServiceWorkerRegistration,\n  options?: StartOptions,\n): void {\n  if (!options?.quiet && !location.href.startsWith(registration.scope)) {\n    devUtils.warn(\n      `\\\nCannot intercept requests on this page because it's outside of the worker's scope (\"${registration.scope}\"). If you wish to mock API requests on this page, you must resolve this scope issue.\n\n- (Recommended) Register the worker at the root level (\"/\") of your application.\n- Set the \"Service-Worker-Allowed\" response header to allow out-of-scope workers.\\\n`,\n    )\n  }\n}\n","import { devUtils } from '../../../utils/internal/devUtils'\n\nexport function printStopMessage(args: { quiet?: boolean } = {}): void {\n  if (args.quiet) {\n    return\n  }\n\n  console.log(\n    `%c${devUtils.formatMessage('Mocking disabled.')}`,\n    'color:orangered;font-weight:bold;',\n  )\n}\n","import { devUtils } from '../../utils/internal/devUtils'\nimport { SetupWorkerInternalContext, StopHandler } from '../glossary'\nimport { printStopMessage } from './utils/printStopMessage'\n\nexport const createStop = (\n  context: SetupWorkerInternalContext,\n): StopHandler => {\n  return function stop() {\n    // Warn developers calling \"worker.stop()\" more times than necessary.\n    // This likely indicates a mistake in their code.\n    if (!context.isMockingEnabled) {\n      devUtils.warn(\n        'Found a redundant \"worker.stop()\" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this \"worker.stop()\" call.',\n      )\n      return\n    }\n\n    /**\n     * Signal the Service Worker to disable mocking for this client.\n     * Use this an an explicit way to stop the mocking, while preserving\n     * the worker-client relation. Does not affect the worker's lifecycle.\n     */\n    context.workerChannel.send('MOCK_DEACTIVATE')\n    context.isMockingEnabled = false\n    window.clearInterval(context.keepAliveInterval)\n\n    printStopMessage({ quiet: context.startOptions?.quiet })\n  }\n}\n","import { RequestHandler } from '../../handlers/RequestHandler'\n\nexport function use(\n  currentHandlers: RequestHandler[],\n  ...handlers: RequestHandler[]\n): void {\n  currentHandlers.unshift(...handlers)\n}\n\nexport function restoreHandlers(handlers: RequestHandler[]): void {\n  handlers.forEach((handler) => {\n    handler.markAsSkipped(false)\n  })\n}\n\nexport function resetHandlers(\n  initialHandlers: RequestHandler[],\n  ...nextHandlers: RequestHandler[]\n) {\n  return nextHandlers.length > 0 ? [...nextHandlers] : [...initialHandlers]\n}\n","import { RequiredDeep } from '../../../typeUtils'\nimport { mergeRight } from '../../../utils/internal/mergeRight'\nimport {\n  SetupWorkerApi,\n  SetupWorkerInternalContext,\n  StartHandler,\n  StartOptions,\n} from '../../glossary'\n\nexport const DEFAULT_START_OPTIONS: RequiredDeep<StartOptions> = {\n  serviceWorker: {\n    url: '/mockServiceWorker.js',\n    options: null as any,\n  },\n  quiet: false,\n  waitUntilReady: true,\n  onUnhandledRequest: 'warn',\n  findWorker(scriptURL, mockServiceWorkerUrl) {\n    return scriptURL === mockServiceWorkerUrl\n  },\n}\n\n/**\n * Returns resolved worker start options, merging the default options\n * with the given custom options.\n */\nexport function resolveStartOptions(\n  initialOptions?: StartOptions,\n): RequiredDeep<StartOptions> {\n  return mergeRight(\n    DEFAULT_START_OPTIONS,\n    initialOptions || {},\n  ) as RequiredDeep<StartOptions>\n}\n\nexport function prepareStartHandler(\n  handler: StartHandler,\n  context: SetupWorkerInternalContext,\n): SetupWorkerApi['start'] {\n  return (initialOptions) => {\n    context.startOptions = resolveStartOptions(initialOptions)\n    return handler(context.startOptions, initialOptions || {})\n  }\n}\n","import {\n  Interceptor,\n  BatchInterceptor,\n  HttpRequestEventMap,\n} from '@mswjs/interceptors'\nimport { FetchInterceptor } from '@mswjs/interceptors/lib/interceptors/fetch'\nimport { XMLHttpRequestInterceptor } from '@mswjs/interceptors/lib/interceptors/XMLHttpRequest'\nimport {\n  SerializedResponse,\n  SetupWorkerInternalContext,\n  StartOptions,\n} from '../glossary'\nimport type { RequiredDeep } from '../../typeUtils'\nimport { handleRequest } from '../../utils/handleRequest'\nimport { MockedRequest } from '../../utils/request/MockedRequest'\nimport { serializeResponse } from '../../utils/logging/serializeResponse'\nimport { createResponseFromIsomorphicResponse } from '../../utils/request/createResponseFromIsomorphicResponse'\n\nexport function createFallbackRequestListener(\n  context: SetupWorkerInternalContext,\n  options: RequiredDeep<StartOptions>,\n): Interceptor<HttpRequestEventMap> {\n  const interceptor = new BatchInterceptor({\n    name: 'fallback',\n    interceptors: [new FetchInterceptor(), new XMLHttpRequestInterceptor()],\n  })\n\n  interceptor.on('request', async (request) => {\n    const mockedRequest = new MockedRequest(request.url, {\n      ...request,\n      body: await request.arrayBuffer(),\n    })\n\n    const response = await handleRequest<SerializedResponse>(\n      mockedRequest,\n      context.requestHandlers,\n      options,\n      context.emitter,\n      {\n        transformResponse(response) {\n          return {\n            status: response.status,\n            statusText: response.statusText,\n            headers: response.headers.all(),\n            body: response.body,\n            delay: response.delay,\n          }\n        },\n        onMockedResponse(_, { handler, publicRequest, parsedRequest }) {\n          if (!options.quiet) {\n            context.emitter.once('response:mocked', (response) => {\n              handler.log(\n                publicRequest,\n                serializeResponse(response),\n                parsedRequest,\n              )\n            })\n          }\n        },\n      },\n    )\n\n    if (response) {\n      request.respondWith(response)\n    }\n  })\n\n  interceptor.on('response', (request, response) => {\n    if (!request.id) {\n      return\n    }\n\n    const browserResponse = createResponseFromIsomorphicResponse(response)\n\n    if (response.headers.get('x-powered-by') === 'msw') {\n      context.emitter.emit('response:mocked', browserResponse, request.id)\n    } else {\n      context.emitter.emit('response:bypass', browserResponse, request.id)\n    }\n  })\n\n  interceptor.apply()\n\n  return interceptor\n}\n","import { encodeBuffer, IsomorphicResponse } from '@mswjs/interceptors'\n\nconst noop = () => {\n  throw new Error('Not implemented')\n}\n\nexport function createResponseFromIsomorphicResponse(\n  response: IsomorphicResponse,\n): Response {\n  return {\n    ...response,\n    ok: response.status >= 200 && response.status < 300,\n    url: '',\n    type: 'default',\n    status: response.status,\n    statusText: response.statusText,\n    headers: response.headers,\n    body: new ReadableStream(),\n    redirected: response.headers.get('Location') != null,\n    async text() {\n      return response.body || ''\n    },\n    async json() {\n      return JSON.parse(response.body || '')\n    },\n    async arrayBuffer() {\n      return encodeBuffer(response.body || '')\n    },\n    bodyUsed: false,\n    formData: noop,\n    blob: noop,\n    clone: noop,\n  }\n}\n","import { createFallbackRequestListener } from './createFallbackRequestListener'\nimport { SetupWorkerInternalContext, StartHandler } from '../glossary'\nimport { printStartMessage } from './utils/printStartMessage'\n\nexport function createFallbackStart(\n  context: SetupWorkerInternalContext,\n): StartHandler {\n  return async function start(options) {\n    context.fallbackInterceptor = createFallbackRequestListener(\n      context,\n      options,\n    )\n\n    printStartMessage({\n      message: 'Mocking enabled (fallback mode).',\n      quiet: options.quiet,\n    })\n\n    return undefined\n  }\n}\n","import { SetupWorkerInternalContext, StopHandler } from '../glossary'\nimport { printStopMessage } from './utils/printStopMessage'\n\nexport function createFallbackStop(\n  context: SetupWorkerInternalContext,\n): StopHandler {\n  return function stop() {\n    context.fallbackInterceptor?.dispose()\n    printStopMessage({ quiet: context.startOptions?.quiet })\n  }\n}\n","import { EventEmitter } from 'stream'\n\n/**\n * Pipes all emitted events from one emitter to another.\n */\nexport function pipeEvents(\n  source: EventEmitter,\n  destination: EventEmitter,\n): void {\n  const rawEmit = source.emit\n\n  // @ts-ignore\n  if (rawEmit._isPiped) {\n    return\n  }\n\n  source.emit = function (event, ...data) {\n    destination.emit(event, ...data)\n    return rawEmit.call(this, event, ...data)\n  }\n\n  // @ts-ignore\n  source.emit._isPiped = true\n}\n","/**\n * Creates an immutable copy of the given array.\n */\nexport function toReadonlyArray<T>(source: Array<T>): ReadonlyArray<T> {\n  const clone = [...source] as Array<T>\n  Object.freeze(clone)\n  return clone\n}\n","import { DefaultBodyType, ResponseResolver } from './handlers/RequestHandler'\nimport {\n  RESTMethods,\n  RestContext,\n  RestHandler,\n  RestRequest,\n} from './handlers/RestHandler'\nimport { Path, PathParams } from './utils/matching/matchRequestUrl'\n\nfunction createRestHandler<Method extends RESTMethods | RegExp>(\n  method: Method,\n) {\n  return <\n    RequestBodyType extends DefaultBodyType = DefaultBodyType,\n    Params extends PathParams<keyof Params> = PathParams,\n    ResponseBody extends DefaultBodyType = DefaultBodyType,\n  >(\n    path: Path,\n    resolver: ResponseResolver<\n      RestRequest<\n        Method extends RESTMethods.HEAD | RESTMethods.GET\n          ? never\n          : RequestBodyType,\n        Params\n      >,\n      RestContext,\n      ResponseBody\n    >,\n  ) => {\n    return new RestHandler(method, path, resolver)\n  }\n}\n\nexport const rest = {\n  all: createRestHandler(/.+/),\n  head: createRestHandler(RESTMethods.HEAD),\n  get: createRestHandler(RESTMethods.GET),\n  post: createRestHandler(RESTMethods.POST),\n  put: createRestHandler(RESTMethods.PUT),\n  delete: createRestHandler(RESTMethods.DELETE),\n  patch: createRestHandler(RESTMethods.PATCH),\n  options: createRestHandler(RESTMethods.OPTIONS),\n}\n","import type { DocumentNode, OperationTypeNode } from 'graphql'\nimport { ResponseResolver } from './handlers/RequestHandler'\nimport {\n  GraphQLHandler,\n  GraphQLContext,\n  GraphQLRequest,\n  GraphQLVariables,\n  ExpectedOperationTypeNode,\n  GraphQLHandlerNameSelector,\n} from './handlers/GraphQLHandler'\nimport { Path } from './utils/matching/matchRequestUrl'\n\nexport interface TypedDocumentNode<\n  Result = { [key: string]: any },\n  Variables = { [key: string]: any },\n> extends DocumentNode {\n  __apiType?: (variables: Variables) => Result\n  __resultType?: Result\n  __variablesType?: Variables\n}\n\nfunction createScopedGraphQLHandler(\n  operationType: ExpectedOperationTypeNode,\n  url: Path,\n) {\n  return <\n    Query extends Record<string, any>,\n    Variables extends GraphQLVariables = GraphQLVariables,\n  >(\n    operationName:\n      | GraphQLHandlerNameSelector\n      | DocumentNode\n      | TypedDocumentNode<Query, Variables>,\n    resolver: ResponseResolver<\n      GraphQLRequest<Variables>,\n      GraphQLContext<Query>\n    >,\n  ) => {\n    return new GraphQLHandler<GraphQLRequest<Variables>>(\n      operationType,\n      operationName,\n      url,\n      resolver,\n    )\n  }\n}\n\nfunction createGraphQLOperationHandler(url: Path) {\n  return <\n    Query extends Record<string, any>,\n    Variables extends GraphQLVariables = GraphQLVariables,\n  >(\n    resolver: ResponseResolver<\n      GraphQLRequest<Variables>,\n      GraphQLContext<Query>\n    >,\n  ) => {\n    return new GraphQLHandler<GraphQLRequest<Variables>>(\n      'all',\n      new RegExp('.*'),\n      url,\n      resolver,\n    )\n  }\n}\n\nconst standardGraphQLHandlers = {\n  /**\n   * Captures any GraphQL operation, regardless of its name, under the current scope.\n   * @example\n   * graphql.operation((req, res, ctx) => {\n   *   return res(ctx.data({ name: 'John' }))\n   * })\n   * @see {@link https://mswjs.io/docs/api/graphql/operation `graphql.operation()`}\n   */\n  operation: createGraphQLOperationHandler('*'),\n\n  /**\n   * Captures a GraphQL query by a given name.\n   * @example\n   * graphql.query('GetUser', (req, res, ctx) => {\n   *   return res(ctx.data({ user: { name: 'John' } }))\n   * })\n   * @see {@link https://mswjs.io/docs/api/graphql/query `graphql.query()`}\n   */\n  query: createScopedGraphQLHandler('query' as OperationTypeNode, '*'),\n\n  /**\n   * Captures a GraphQL mutation by a given name.\n   * @example\n   * graphql.mutation('SavePost', (req, res, ctx) => {\n   *   return res(ctx.data({ post: { id: 'abc-123' } }))\n   * })\n   * @see {@link https://mswjs.io/docs/api/graphql/mutation `graphql.mutation()`}\n   */\n  mutation: createScopedGraphQLHandler('mutation' as OperationTypeNode, '*'),\n}\n\nfunction createGraphQLLink(url: Path): typeof standardGraphQLHandlers {\n  return {\n    operation: createGraphQLOperationHandler(url),\n    query: createScopedGraphQLHandler('query' as OperationTypeNode, url),\n    mutation: createScopedGraphQLHandler('mutation' as OperationTypeNode, url),\n  }\n}\n\nexport const graphql = {\n  ...standardGraphQLHandlers,\n  link: createGraphQLLink,\n}\n"]},"metadata":{},"sourceType":"script"}